// Copyright Â© 2024 PSPDFKit GmbH. All rights reserved.
//
// THIS SOURCE CODE AND ANY ACCOMPANYING DOCUMENTATION ARE PROTECTED BY INTERNATIONAL COPYRIGHT LAW
// AND MAY NOT BE RESOLD OR REDISTRIBUTED. USAGE IS BOUND TO THE PSPDFKIT LICENSE AGREEMENT.
// UNAUTHORIZED REPRODUCTION OR DISTRIBUTION IS SUBJECT TO CIVIL AND CRIMINAL PENALTIES.
// This notice may not be removed from this file.
// Autogenerated from Pigeon (v22.5.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.pspdfkit.flutter.pspdfkit.api

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is PspdfkitApiError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): PspdfkitApiError {
  return PspdfkitApiError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class PspdfkitApiError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

enum class AndroidPermissionStatus(val raw: Int) {
  NOT_DETERMINED(0),
  DENIED(1),
  AUTHORIZED(2),
  DENIED_NEVER_ASK(3);

  companion object {
    fun ofRaw(raw: Int): AndroidPermissionStatus? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Represents the native annotation type. */
enum class AnnotationType(val raw: Int) {
  ALL(0),
  NONE(1),
  UNDEFINED(2),
  LINK(3),
  HIGHLIGHT(4),
  STRIKEOUT(5),
  UNDERLINE(6),
  SQUIGGLY(7),
  FREE_TEXT(8),
  INK(9),
  SQUARE(10),
  CIRCLE(11),
  LINE(12),
  NOTE(13),
  STAMP(14),
  CARET(15),
  RICH_MEDIA(16),
  SCREEN(17),
  WIDGET(18),
  FILE(19),
  SOUND(20),
  POLYGON(21),
  POLYLINE(22),
  POPUP(23),
  WATERMARK(24),
  TRAP_NET(25),
  TYPE3D(26),
  REDACT(27);

  companion object {
    fun ofRaw(raw: Int): AnnotationType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class AnnotationTool(val raw: Int) {
  INK_PEN(0),
  INK_MAGIC(1),
  INK_HIGHLIGHTER(2),
  FREE_TEXT(3),
  FREE_TEXT_CALL_OUT(4),
  STAMP(5),
  IMAGE(6),
  HIGHLIGHT(7),
  UNDERLINE(8),
  SQUIGGLY(9),
  STRIKE_OUT(10),
  LINE(11),
  ARROW(12),
  SQUARE(13),
  CIRCLE(14),
  POLYGON(15),
  POLYLINE(16),
  ERASER(17),
  CLOUDY(18),
  LINK(19),
  CARET(20),
  RICH_MEDIA(21),
  SCREEN(22),
  FILE(23),
  WIDGET(24),
  REDACTION(25),
  SIGNATURE(26),
  STAMP_IMAGE(27),
  NOTE(28),
  SOUND(29),
  MEASUREMENT_AREA_RECT(30),
  MEASUREMENT_AREA_POLYGON(31),
  MEASUREMENT_AREA_ELLIPSE(32),
  MEASUREMENT_PERIMETER(33),
  MEASUREMENT_DISTANCE(34);

  companion object {
    fun ofRaw(raw: Int): AnnotationTool? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class AnnotationToolVariant(val raw: Int) {
  INK_PEN(0),
  INK_MAGIC(1),
  INK_HIGHLIGHTER(2),
  FREE_TEXT(3),
  FREE_TEXT_CALL_OUT(4),
  STAMP(5),
  IMAGE(6),
  HIGHLIGHT(7),
  UNDERLINE(8);

  companion object {
    fun ofRaw(raw: Int): AnnotationToolVariant? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class AnnotationProcessingMode(val raw: Int) {
  FLATTEN(0),
  REMOVE(1),
  EMBED(2),
  PRINT(3);

  companion object {
    fun ofRaw(raw: Int): AnnotationProcessingMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class DocumentPermissions(val raw: Int) {
  /** Allow printing of document. */
  PRINTING(0),
  /** Modify the contents of the document. */
  MODIFICATION(1),
  /** Copy text and images from the document. */
  EXTRACT(2),
  /** Add or modify text annotations, fill in interactive form fields. */
  ANNOTATIONS_AND_FORMS(3),
  /** Fill in existing interactive form fields (including signature fields). */
  FILL_FORMS(4),
  /** Extract text and images from the document. */
  EXTRACT_ACCESSIBILITY(5),
  /** Assemble the document (insert, rotate, or delete pages and create document outline items or thumbnail images). */
  ASSEMBLE(6),
  /** Print high quality. */
  PRINT_HIGH_QUALITY(7);

  companion object {
    fun ofRaw(raw: Int): DocumentPermissions? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The PDF version of a document. */
enum class PdfVersion(val raw: Int) {
  PDF_1_0(0),
  PDF_1_1(1),
  PDF_1_2(2),
  PDF_1_3(3),
  PDF_1_4(4),
  PDF_1_5(5),
  PDF_1_6(6),
  PDF_1_7(7);

  companion object {
    fun ofRaw(raw: Int): PdfVersion? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PdfFormFieldTypes(val raw: Int) {
  TEXT(0),
  CHECKBOX(1),
  RADIO_BUTTON(2),
  COMBO_BOX(3),
  LIST_BOX(4),
  SIGNATURE(5),
  BUTTON(6),
  UNKNOWN(7);

  companion object {
    fun ofRaw(raw: Int): PdfFormFieldTypes? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class NutrientEvent(val raw: Int) {
  /** Event triggered when annotations are created. */
  ANNOTATIONS_CREATED(0),
  /** Event triggered when annotations are pressed. */
  ANNOTATIONS_DESELECTED(1),
  /** Event triggered when annotations are updated. */
  ANNOTATIONS_UPDATED(2),
  /** Event triggered when annotations are deleted. */
  ANNOTATIONS_DELETED(3),
  /** Event triggered when annotations are focused. */
  ANNOTATIONS_SELECTED(4),
  /** Event triggered when form field values are updated. */
  FORM_FIELD_VALUES_UPDATED(5),
  /** Event triggered when form fields are loaded. */
  FORM_FIELD_SELECTED(6),
  /** Event triggered when form fields are about to be saved. */
  FORM_FIELD_DESELECTED(7),
  /** Event triggered when text selection changes. */
  TEXT_SELECTION_CHANGED(8);

  companion object {
    fun ofRaw(raw: Int): NutrientEvent? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PdfRect (
  val x: Double,
  val y: Double,
  val width: Double,
  val height: Double
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PdfRect {
      val x = pigeonVar_list[0] as Double
      val y = pigeonVar_list[1] as Double
      val width = pigeonVar_list[2] as Double
      val height = pigeonVar_list[3] as Double
      return PdfRect(x, y, width, height)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      x,
      y,
      width,
      height,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PageInfo (
  /** The index of the page. This is a zero-based index. */
  val pageIndex: Long,
  /** The height of the page in points. */
  val height: Double,
  /** The width of the page in points. */
  val width: Double,
  /** The rotation of the page in degrees. */
  val rotation: Long,
  /** The label of the page. */
  val label: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PageInfo {
      val pageIndex = pigeonVar_list[0] as Long
      val height = pigeonVar_list[1] as Double
      val width = pigeonVar_list[2] as Double
      val rotation = pigeonVar_list[3] as Long
      val label = pigeonVar_list[4] as String
      return PageInfo(pageIndex, height, width, rotation, label)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      pageIndex,
      height,
      width,
      rotation,
      label,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class DocumentSaveOptions (
  /** The password is used to encrypt the document. On Web, it's used as the user password. */
  val userPassword: String? = null,
  /** The owner password is used to encrypt the document and set permissions. It's only used on Web. */
  val ownerPassword: String? = null,
  /** Flatten annotations and form fields into the page content. */
  val flatten: Boolean? = null,
  /** Whether to save the document incrementally. */
  val incremental: Boolean? = null,
  /** The permissions to set on the document. See [DocumentPermissions] for more information. */
  val permissions: List<DocumentPermissions?>? = null,
  /** The PDF version to save the document as. */
  val pdfVersion: PdfVersion? = null,
  /** Whether to exclude annotations from the exported document. */
  val excludeAnnotations: Boolean? = null,
  /** Whether to exclude annotations that have the noPrint flag set to true from the exported document (Standalone only) */
  val saveForPrinting: Boolean? = null,
  /** Whether to include comments in the exported document (Server-Backed only). */
  val includeComments: Boolean? = null,
  /** Whether tp allow you to export a PDF in PDF/A format. */
  val outputFormat: Any? = null,
  /** Whether to optimize the document for the web. */
  val optimize: Boolean? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): DocumentSaveOptions {
      val userPassword = pigeonVar_list[0] as String?
      val ownerPassword = pigeonVar_list[1] as String?
      val flatten = pigeonVar_list[2] as Boolean?
      val incremental = pigeonVar_list[3] as Boolean?
      val permissions = pigeonVar_list[4] as List<DocumentPermissions?>?
      val pdfVersion = pigeonVar_list[5] as PdfVersion?
      val excludeAnnotations = pigeonVar_list[6] as Boolean?
      val saveForPrinting = pigeonVar_list[7] as Boolean?
      val includeComments = pigeonVar_list[8] as Boolean?
      val outputFormat = pigeonVar_list[9]
      val optimize = pigeonVar_list[10] as Boolean?
      return DocumentSaveOptions(userPassword, ownerPassword, flatten, incremental, permissions, pdfVersion, excludeAnnotations, saveForPrinting, includeComments, outputFormat, optimize)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      userPassword,
      ownerPassword,
      flatten,
      incremental,
      permissions,
      pdfVersion,
      excludeAnnotations,
      saveForPrinting,
      includeComments,
      outputFormat,
      optimize,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PdfFormOption (
  /** The value of the option. */
  val value: String,
  /** The label of the option. */
  val label: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PdfFormOption {
      val value = pigeonVar_list[0] as String
      val label = pigeonVar_list[1] as String
      return PdfFormOption(value, label)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      value,
      label,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class FormFieldData (
  val name: String,
  val alternativeFieldName: String? = null,
  val fullyQualifiedName: String? = null,
  val type: PdfFormFieldTypes,
  val annotations: Any? = null,
  val isReadOnly: Boolean? = null,
  val isRequired: Boolean? = null,
  val isExported: Boolean? = null,
  val isDirty: Boolean? = null,
  val options: List<PdfFormOption?>? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): FormFieldData {
      val name = pigeonVar_list[0] as String
      val alternativeFieldName = pigeonVar_list[1] as String?
      val fullyQualifiedName = pigeonVar_list[2] as String?
      val type = pigeonVar_list[3] as PdfFormFieldTypes
      val annotations = pigeonVar_list[4]
      val isReadOnly = pigeonVar_list[5] as Boolean?
      val isRequired = pigeonVar_list[6] as Boolean?
      val isExported = pigeonVar_list[7] as Boolean?
      val isDirty = pigeonVar_list[8] as Boolean?
      val options = pigeonVar_list[9] as List<PdfFormOption?>?
      return FormFieldData(name, alternativeFieldName, fullyQualifiedName, type, annotations, isReadOnly, isRequired, isExported, isDirty, options)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      name,
      alternativeFieldName,
      fullyQualifiedName,
      type,
      annotations,
      isReadOnly,
      isRequired,
      isExported,
      isDirty,
      options,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PointF (
  val x: Double,
  val y: Double
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PointF {
      val x = pigeonVar_list[0] as Double
      val y = pigeonVar_list[1] as Double
      return PointF(x, y)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      x,
      y,
    )
  }
}
private open class PspdfkitApiPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AndroidPermissionStatus.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AnnotationType.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AnnotationTool.ofRaw(it.toInt())
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AnnotationToolVariant.ofRaw(it.toInt())
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AnnotationProcessingMode.ofRaw(it.toInt())
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          DocumentPermissions.ofRaw(it.toInt())
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PdfVersion.ofRaw(it.toInt())
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PdfFormFieldTypes.ofRaw(it.toInt())
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          NutrientEvent.ofRaw(it.toInt())
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PdfRect.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PageInfo.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          DocumentSaveOptions.fromList(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PdfFormOption.fromList(it)
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FormFieldData.fromList(it)
        }
      }
      143.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointF.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is AndroidPermissionStatus -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is AnnotationType -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is AnnotationTool -> {
        stream.write(131)
        writeValue(stream, value.raw)
      }
      is AnnotationToolVariant -> {
        stream.write(132)
        writeValue(stream, value.raw)
      }
      is AnnotationProcessingMode -> {
        stream.write(133)
        writeValue(stream, value.raw)
      }
      is DocumentPermissions -> {
        stream.write(134)
        writeValue(stream, value.raw)
      }
      is PdfVersion -> {
        stream.write(135)
        writeValue(stream, value.raw)
      }
      is PdfFormFieldTypes -> {
        stream.write(136)
        writeValue(stream, value.raw)
      }
      is NutrientEvent -> {
        stream.write(137)
        writeValue(stream, value.raw)
      }
      is PdfRect -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is PageInfo -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is DocumentSaveOptions -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is PdfFormOption -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      is FormFieldData -> {
        stream.write(142)
        writeValue(stream, value.toList())
      }
      is PointF -> {
        stream.write(143)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/**
 * The API for interacting with a PDF document.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface PspdfkitApi {
  fun getFrameworkVersion(callback: (Result<String?>) -> Unit)
  fun setLicenseKey(licenseKey: String?, callback: (Result<Unit>) -> Unit)
  fun setLicenseKeys(androidLicenseKey: String?, iOSLicenseKey: String?, webLicenseKey: String?, callback: (Result<Unit>) -> Unit)
  fun present(document: String, configuration: Map<String, Any>?, callback: (Result<Boolean?>) -> Unit)
  fun presentInstant(serverUrl: String, jwt: String, configuration: Map<String, Any>?, callback: (Result<Boolean?>) -> Unit)
  fun setFormFieldValue(value: String, fullyQualifiedName: String, callback: (Result<Boolean?>) -> Unit)
  fun getFormFieldValue(fullyQualifiedName: String, callback: (Result<String?>) -> Unit)
  fun applyInstantJson(annotationsJson: String, callback: (Result<Boolean?>) -> Unit)
  fun exportInstantJson(callback: (Result<String?>) -> Unit)
  fun addAnnotation(jsonAnnotation: String, callback: (Result<Boolean?>) -> Unit)
  fun removeAnnotation(jsonAnnotation: String, callback: (Result<Boolean?>) -> Unit)
  fun getAnnotations(pageIndex: Long, type: String, callback: (Result<Any?>) -> Unit)
  fun getAllUnsavedAnnotations(callback: (Result<Any?>) -> Unit)
  fun processAnnotations(type: AnnotationType, processingMode: AnnotationProcessingMode, destinationPath: String, callback: (Result<Boolean?>) -> Unit)
  fun importXfdf(xfdfString: String, callback: (Result<Boolean?>) -> Unit)
  fun exportXfdf(xfdfPath: String, callback: (Result<Boolean?>) -> Unit)
  fun save(callback: (Result<Boolean?>) -> Unit)
  fun setDelayForSyncingLocalChanges(delay: Double, callback: (Result<Boolean?>) -> Unit)
  fun setListenToServerChanges(listen: Boolean, callback: (Result<Boolean?>) -> Unit)
  fun syncAnnotations(callback: (Result<Boolean?>) -> Unit)
  fun checkAndroidWriteExternalStoragePermission(callback: (Result<Boolean?>) -> Unit)
  fun requestAndroidWriteExternalStoragePermission(callback: (Result<AndroidPermissionStatus>) -> Unit)
  fun openAndroidSettings(callback: (Result<Unit>) -> Unit)
  fun setAnnotationPresetConfigurations(configurations: Map<String, Any?>, callback: (Result<Boolean?>) -> Unit)
  fun getTemporaryDirectory(callback: (Result<String>) -> Unit)
  fun getAuthorName(callback: (Result<String>) -> Unit)
  /**
   * Generate PDF from Images, Template, and Patterns.
   * [pages]: [NewPage]s to be added to the PDF.
   * [outputPath]: The path to the output file.
   * Returns the path to the generated PDF path or null if the input is invalid or if the PDF generation fails.
   */
  fun generatePdf(pages: List<Map<String, Any>>, outputPath: String, callback: (Result<String?>) -> Unit)
  /**
   * Generates a PDF from HTML string.
   *
   * [html]: The HTML string to be converted to PDF.
   * [outPutFile]: The path to the output file.
   * Returns the path to the generated PDF file or null if the input is invalid or if the PDF generation fails.
   */
  fun generatePdfFromHtmlString(html: String, outPutFile: String, options: Map<String, Any>?, callback: (Result<String?>) -> Unit)
  fun generatePdfFromHtmlUri(htmlUri: String, outPutFile: String, options: Map<String, Any>?, callback: (Result<String?>) -> Unit)
  /** Configure Nutrient Analytics events. */
  fun enableAnalyticsEvents(enable: Boolean)

  companion object {
    /** The codec used by PspdfkitApi. */
    val codec: MessageCodec<Any?> by lazy {
      PspdfkitApiPigeonCodec()
    }
    /** Sets up an instance of `PspdfkitApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: PspdfkitApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.getFrameworkVersion$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getFrameworkVersion{ result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setLicenseKey$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val licenseKeyArg = args[0] as String?
            api.setLicenseKey(licenseKeyArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setLicenseKeys$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val androidLicenseKeyArg = args[0] as String?
            val iOSLicenseKeyArg = args[1] as String?
            val webLicenseKeyArg = args[2] as String?
            api.setLicenseKeys(androidLicenseKeyArg, iOSLicenseKeyArg, webLicenseKeyArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.present$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val documentArg = args[0] as String
            val configurationArg = args[1] as Map<String, Any>?
            api.present(documentArg, configurationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.presentInstant$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val serverUrlArg = args[0] as String
            val jwtArg = args[1] as String
            val configurationArg = args[2] as Map<String, Any>?
            api.presentInstant(serverUrlArg, jwtArg, configurationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setFormFieldValue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val valueArg = args[0] as String
            val fullyQualifiedNameArg = args[1] as String
            api.setFormFieldValue(valueArg, fullyQualifiedNameArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.getFormFieldValue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val fullyQualifiedNameArg = args[0] as String
            api.getFormFieldValue(fullyQualifiedNameArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.applyInstantJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val annotationsJsonArg = args[0] as String
            api.applyInstantJson(annotationsJsonArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.exportInstantJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.exportInstantJson{ result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.addAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val jsonAnnotationArg = args[0] as String
            api.addAnnotation(jsonAnnotationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.removeAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val jsonAnnotationArg = args[0] as String
            api.removeAnnotation(jsonAnnotationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.getAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val typeArg = args[1] as String
            api.getAnnotations(pageIndexArg, typeArg) { result: Result<Any?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.getAllUnsavedAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getAllUnsavedAnnotations{ result: Result<Any?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.processAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val typeArg = args[0] as AnnotationType
            val processingModeArg = args[1] as AnnotationProcessingMode
            val destinationPathArg = args[2] as String
            api.processAnnotations(typeArg, processingModeArg, destinationPathArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.importXfdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfStringArg = args[0] as String
            api.importXfdf(xfdfStringArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.exportXfdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfPathArg = args[0] as String
            api.exportXfdf(xfdfPathArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.save$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.save{ result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setDelayForSyncingLocalChanges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val delayArg = args[0] as Double
            api.setDelayForSyncingLocalChanges(delayArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setListenToServerChanges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val listenArg = args[0] as Boolean
            api.setListenToServerChanges(listenArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.syncAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.syncAnnotations{ result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.checkAndroidWriteExternalStoragePermission$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.checkAndroidWriteExternalStoragePermission{ result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.requestAndroidWriteExternalStoragePermission$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.requestAndroidWriteExternalStoragePermission{ result: Result<AndroidPermissionStatus> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.openAndroidSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.openAndroidSettings{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setAnnotationPresetConfigurations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val configurationsArg = args[0] as Map<String, Any?>
            api.setAnnotationPresetConfigurations(configurationsArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.getTemporaryDirectory$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getTemporaryDirectory{ result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.getAuthorName$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getAuthorName{ result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.generatePdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pagesArg = args[0] as List<Map<String, Any>>
            val outputPathArg = args[1] as String
            api.generatePdf(pagesArg, outputPathArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.generatePdfFromHtmlString$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val htmlArg = args[0] as String
            val outPutFileArg = args[1] as String
            val optionsArg = args[2] as Map<String, Any>?
            api.generatePdfFromHtmlString(htmlArg, outPutFileArg, optionsArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.generatePdfFromHtmlUri$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val htmlUriArg = args[0] as String
            val outPutFileArg = args[1] as String
            val optionsArg = args[2] as Map<String, Any>?
            api.generatePdfFromHtmlUri(htmlUriArg, outPutFileArg, optionsArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.enableAnalyticsEvents$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enableArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.enableAnalyticsEvents(enableArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class PspdfkitFlutterApiCallbacks(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by PspdfkitFlutterApiCallbacks. */
    val codec: MessageCodec<Any?> by lazy {
      PspdfkitApiPigeonCodec()
    }
  }
  /** onPAuse callback for FlutterPdfActivity */
  fun onPdfActivityOnPause(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onPdfActivityOnPause$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onPdfFragmentAdded(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onPdfFragmentAdded$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onDocumentLoaded(documentIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onDocumentLoaded$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** ViewControllerWillDismiss callback for PDFViewController */
  fun onPdfViewControllerWillDismiss(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onPdfViewControllerWillDismiss$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** ViewControllerDidDismiss callback for PDFViewController */
  fun onPdfViewControllerDidDismiss(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onPdfViewControllerDidDismiss$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when instant synchronization starts. */
  fun onInstantSyncStarted(documentIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantSyncStarted$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when instant synchronization ends. */
  fun onInstantSyncFinished(documentIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantSyncFinished$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when instant synchronization fails. */
  fun onInstantSyncFailed(documentIdArg: String, errorArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantSyncFailed$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when instant authentication is done. */
  fun onInstantAuthenticationFinished(documentIdArg: String, validJWTArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantAuthenticationFinished$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, validJWTArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when instant authentication fails. */
  fun onInstantAuthenticationFailed(documentIdArg: String, errorArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantAuthenticationFailed$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Only available on iOS.
   * Called when instant document download is done.
   */
  fun onInstantDownloadFinished(documentIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantDownloadFinished$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Only available on iOS.
   * Called when instant document download fails.
   */
  fun onInstantDownloadFailed(documentIdArg: String, errorArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantDownloadFailed$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface PspdfkitWidgetControllerApi {
  /**
   * Sets the value of a form field by specifying its fully qualified field name.
   * This method is deprecated. Use [PdfDocument.setFormFieldValue] instead.
   */
  fun setFormFieldValue(value: String, fullyQualifiedName: String, callback: (Result<Boolean?>) -> Unit)
  /** Gets the form field value by specifying its fully qualified name. */
  fun getFormFieldValue(fullyQualifiedName: String, callback: (Result<String?>) -> Unit)
  /** Applies Instant document JSON to the presented document. */
  fun applyInstantJson(annotationsJson: String, callback: (Result<Boolean?>) -> Unit)
  /** Exports Instant document JSON from the presented document. */
  fun exportInstantJson(callback: (Result<String?>) -> Unit)
  /**
   * Adds the given annotation to the presented document.
   * `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
   */
  fun addAnnotation(jsonAnnotation: String, callback: (Result<Boolean?>) -> Unit)
  /**
   * Removes the given annotation from the presented document.
   * `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
   */
  fun removeAnnotation(jsonAnnotation: String, callback: (Result<Boolean?>) -> Unit)
  /** Returns a list of JSON dictionaries for all the annotations of the given `type` on the given `pageIndex`. */
  fun getAnnotations(pageIndex: Long, type: String, callback: (Result<Any>) -> Unit)
  /** Returns a list of JSON dictionaries for all the unsaved annotations in the presented document. */
  fun getAllUnsavedAnnotations(callback: (Result<Any>) -> Unit)
  /**
   * Processes annotations of the given type with the provided processing
   * mode and stores the PDF at the given destination path.
   */
  fun processAnnotations(type: AnnotationType, processingMode: AnnotationProcessingMode, destinationPath: String, callback: (Result<Boolean>) -> Unit)
  /** Imports annotations from the XFDF file at the given path. */
  fun importXfdf(xfdfString: String, callback: (Result<Boolean>) -> Unit)
  /** Exports annotations to the XFDF file at the given path. */
  fun exportXfdf(xfdfPath: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Saves the document back to its original location if it has been changed.
   * If there were no changes to the document, the document file will not be modified.
   */
  fun save(callback: (Result<Boolean>) -> Unit)
  /**
   * Sets the annotation preset configurations for the given annotation tools.
   * @param configurations A map of annotation tools and their corresponding configurations.
   * @param modifyAssociatedAnnotations Whether to modify the annotations associated with the old configuration. Only used for Android.
   * @return True if the configurations were set successfully, false otherwise.
   */
  fun setAnnotationConfigurations(configurations: Map<String, Map<String, Any>>, callback: (Result<Boolean?>) -> Unit)
  /**
   * Gets the visible rect of the given page.
   * pageIndex The index of the page. This is a zero-based index.
   * Returns a [Future] that completes with the visible rect of the given page.
   */
  fun getVisibleRect(pageIndex: Long, callback: (Result<PdfRect>) -> Unit)
  /**
   * Zooms to the given rect on the given page.
   * pageIndex The index of the page. This is a zero-based index.
   * rect The rect to zoom to.
   * Returns a [Future] that completes when the zoom operation is done.
   */
  fun zoomToRect(pageIndex: Long, rect: PdfRect, animated: Boolean?, duration: Double?, callback: (Result<Boolean>) -> Unit)
  /**
   * Gets the zoom scale of the given page.
   * pageIndex The index of the page. This is a zero-based index.
   * Returns a [Future] that completes with the zoom scale of the given page.
   */
  fun getZoomScale(pageIndex: Long, callback: (Result<Double>) -> Unit)
  fun addEventListener(event: NutrientEvent)
  fun removeEventListener(event: NutrientEvent)

  companion object {
    /** The codec used by PspdfkitWidgetControllerApi. */
    val codec: MessageCodec<Any?> by lazy {
      PspdfkitApiPigeonCodec()
    }
    /** Sets up an instance of `PspdfkitWidgetControllerApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: PspdfkitWidgetControllerApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.setFormFieldValue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val valueArg = args[0] as String
            val fullyQualifiedNameArg = args[1] as String
            api.setFormFieldValue(valueArg, fullyQualifiedNameArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.getFormFieldValue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val fullyQualifiedNameArg = args[0] as String
            api.getFormFieldValue(fullyQualifiedNameArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.applyInstantJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val annotationsJsonArg = args[0] as String
            api.applyInstantJson(annotationsJsonArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.exportInstantJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.exportInstantJson{ result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.addAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val jsonAnnotationArg = args[0] as String
            api.addAnnotation(jsonAnnotationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.removeAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val jsonAnnotationArg = args[0] as String
            api.removeAnnotation(jsonAnnotationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.getAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val typeArg = args[1] as String
            api.getAnnotations(pageIndexArg, typeArg) { result: Result<Any> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.getAllUnsavedAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getAllUnsavedAnnotations{ result: Result<Any> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.processAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val typeArg = args[0] as AnnotationType
            val processingModeArg = args[1] as AnnotationProcessingMode
            val destinationPathArg = args[2] as String
            api.processAnnotations(typeArg, processingModeArg, destinationPathArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.importXfdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfStringArg = args[0] as String
            api.importXfdf(xfdfStringArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.exportXfdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfPathArg = args[0] as String
            api.exportXfdf(xfdfPathArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.save$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.save{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.setAnnotationConfigurations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val configurationsArg = args[0] as Map<String, Map<String, Any>>
            api.setAnnotationConfigurations(configurationsArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.getVisibleRect$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            api.getVisibleRect(pageIndexArg) { result: Result<PdfRect> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.zoomToRect$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val rectArg = args[1] as PdfRect
            val animatedArg = args[2] as Boolean?
            val durationArg = args[3] as Double?
            api.zoomToRect(pageIndexArg, rectArg, animatedArg, durationArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.getZoomScale$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            api.getZoomScale(pageIndexArg) { result: Result<Double> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.addEventListener$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val eventArg = args[0] as NutrientEvent
            val wrapped: List<Any?> = try {
              api.addEventListener(eventArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.removeEventListener$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val eventArg = args[0] as NutrientEvent
            val wrapped: List<Any?> = try {
              api.removeEventListener(eventArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface PdfDocumentApi {
  /**
   * Returns the page info for the given page index.
   * pageIndex The index of the page. This is a zero-based index.
   */
  fun getPageInfo(pageIndex: Long, callback: (Result<PageInfo>) -> Unit)
  /**
   * Exports the document as a PDF.
   * options:[DocumentSaveOptions] The options to use when exporting the document.
   * Returns a [Uint8List] containing the exported PDF data.
   */
  fun exportPdf(options: DocumentSaveOptions?, callback: (Result<ByteArray>) -> Unit)
  fun getFormField(fieldName: String, callback: (Result<Map<String, Any?>>) -> Unit)
  /** Returns a list of all form fields in the document. */
  fun getFormFields(callback: (Result<List<Map<String, Any?>>>) -> Unit)
  /** Sets the value of a form field by specifying its fully qualified field name. */
  fun setFormFieldValue(value: String, fullyQualifiedName: String, callback: (Result<Boolean?>) -> Unit)
  /** Gets the form field value by specifying its fully qualified name. */
  fun getFormFieldValue(fullyQualifiedName: String, callback: (Result<String?>) -> Unit)
  /** Applies Instant document JSON to the presented document. */
  fun applyInstantJson(annotationsJson: String, callback: (Result<Boolean?>) -> Unit)
  /** Exports Instant document JSON from the presented document. */
  fun exportInstantJson(callback: (Result<String?>) -> Unit)
  /**
   * Adds the given annotation to the presented document.
   * `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
   */
  fun addAnnotation(jsonAnnotation: String, callback: (Result<Boolean?>) -> Unit)
  /**
   * Removes the given annotation from the presented document.
   * `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
   */
  fun removeAnnotation(jsonAnnotation: String, callback: (Result<Boolean?>) -> Unit)
  /** Returns a list of JSON dictionaries for all the annotations of the given `type` on the given `pageIndex`. */
  fun getAnnotations(pageIndex: Long, type: String, callback: (Result<Any>) -> Unit)
  /** Returns a list of JSON dictionaries for all the unsaved annotations in the presented document. */
  fun getAllUnsavedAnnotations(callback: (Result<Any>) -> Unit)
  /** Imports annotations from the XFDF file at the given path. */
  fun importXfdf(xfdfString: String, callback: (Result<Boolean>) -> Unit)
  /** Exports annotations to the XFDF file at the given path. */
  fun exportXfdf(xfdfPath: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Saves the document back to its original location if it has been changed.
   * If there were no changes to the document, the document file will not be modified.
   */
  fun save(outputPath: String?, options: DocumentSaveOptions?, callback: (Result<Boolean>) -> Unit)

  companion object {
    /** The codec used by PdfDocumentApi. */
    val codec: MessageCodec<Any?> by lazy {
      PspdfkitApiPigeonCodec()
    }
    /** Sets up an instance of `PdfDocumentApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: PdfDocumentApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getPageInfo$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            api.getPageInfo(pageIndexArg) { result: Result<PageInfo> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.exportPdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val optionsArg = args[0] as DocumentSaveOptions?
            api.exportPdf(optionsArg) { result: Result<ByteArray> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getFormField$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val fieldNameArg = args[0] as String
            api.getFormField(fieldNameArg) { result: Result<Map<String, Any?>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getFormFields$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getFormFields{ result: Result<List<Map<String, Any?>>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.setFormFieldValue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val valueArg = args[0] as String
            val fullyQualifiedNameArg = args[1] as String
            api.setFormFieldValue(valueArg, fullyQualifiedNameArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getFormFieldValue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val fullyQualifiedNameArg = args[0] as String
            api.getFormFieldValue(fullyQualifiedNameArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.applyInstantJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val annotationsJsonArg = args[0] as String
            api.applyInstantJson(annotationsJsonArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.exportInstantJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.exportInstantJson{ result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.addAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val jsonAnnotationArg = args[0] as String
            api.addAnnotation(jsonAnnotationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.removeAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val jsonAnnotationArg = args[0] as String
            api.removeAnnotation(jsonAnnotationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val typeArg = args[1] as String
            api.getAnnotations(pageIndexArg, typeArg) { result: Result<Any> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getAllUnsavedAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getAllUnsavedAnnotations{ result: Result<Any> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.importXfdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfStringArg = args[0] as String
            api.importXfdf(xfdfStringArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.exportXfdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfPathArg = args[0] as String
            api.exportXfdf(xfdfPathArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.save$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val outputPathArg = args[0] as String?
            val optionsArg = args[1] as DocumentSaveOptions?
            api.save(outputPathArg, optionsArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class PspdfkitWidgetCallbacks(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by PspdfkitWidgetCallbacks. */
    val codec: MessageCodec<Any?> by lazy {
      PspdfkitApiPigeonCodec()
    }
  }
  fun onDocumentLoaded(documentIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetCallbacks.onDocumentLoaded$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onDocumentError(documentIdArg: String, errorArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetCallbacks.onDocumentError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onPageChanged(documentIdArg: String, pageIndexArg: Long, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetCallbacks.onPageChanged$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, pageIndexArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onPageClick(documentIdArg: String, pageIndexArg: Long, pointArg: PointF?, annotationArg: Any?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetCallbacks.onPageClick$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, pageIndexArg, pointArg, annotationArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onDocumentSaved(documentIdArg: String, pathArg: String?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetCallbacks.onDocumentSaved$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, pathArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class NutrientEventsCallbacks(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by NutrientEventsCallbacks. */
    val codec: MessageCodec<Any?> by lazy {
      PspdfkitApiPigeonCodec()
    }
  }
  fun onEvent(eventArg: NutrientEvent, dataArg: Any?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.NutrientEventsCallbacks.onEvent$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(eventArg, dataArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class AnalyticsEventsCallback(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by AnalyticsEventsCallback. */
    val codec: MessageCodec<Any?> by lazy {
      PspdfkitApiPigeonCodec()
    }
  }
  fun onEvent(eventArg: String, attributesArg: Map<String, Any?>?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pspdfkit_flutter.AnalyticsEventsCallback.onEvent$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(eventArg, attributesArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(PspdfkitApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
