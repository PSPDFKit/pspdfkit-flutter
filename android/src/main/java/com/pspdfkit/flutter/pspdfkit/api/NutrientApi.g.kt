// Copyright Â© 2024-2026 PSPDFKit GmbH. All rights reserved.
//
// THIS SOURCE CODE AND ANY ACCOMPANYING DOCUMENTATION ARE PROTECTED BY INTERNATIONAL COPYRIGHT LAW
// AND MAY NOT BE RESOLD OR REDISTRIBUTED. USAGE IS BOUND TO THE PSPDFKIT LICENSE AGREEMENT.
// UNAUTHORIZED REPRODUCTION OR DISTRIBUTION IS SUBJECT TO CIVIL AND CRIMINAL PENALTIES.
// This notice may not be removed from this file.
// Autogenerated from Pigeon (v24.2.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.pspdfkit.flutter.pspdfkit.api

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is NutrientApiError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): NutrientApiError {
  return NutrientApiError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class NutrientApiError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

enum class AndroidPermissionStatus(val raw: Int) {
  NOT_DETERMINED(0),
  DENIED(1),
  AUTHORIZED(2),
  DENIED_NEVER_ASK(3);

  companion object {
    fun ofRaw(raw: Int): AndroidPermissionStatus? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Represents the native annotation type. */
enum class AnnotationType(val raw: Int) {
  ALL(0),
  NONE(1),
  UNDEFINED(2),
  LINK(3),
  HIGHLIGHT(4),
  STRIKEOUT(5),
  UNDERLINE(6),
  SQUIGGLY(7),
  FREE_TEXT(8),
  INK(9),
  SQUARE(10),
  CIRCLE(11),
  LINE(12),
  NOTE(13),
  STAMP(14),
  CARET(15),
  MEDIA(16),
  SCREEN(17),
  WIDGET(18),
  FILE(19),
  SOUND(20),
  POLYGON(21),
  POLYLINE(22),
  POPUP(23),
  WATERMARK(24),
  TRAP_NET(25),
  TYPE3D(26),
  REDACT(27),
  IMAGE(28);

  companion object {
    fun ofRaw(raw: Int): AnnotationType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class AnnotationTool(val raw: Int) {
  INK_PEN(0),
  INK_MAGIC(1),
  INK_HIGHLIGHTER(2),
  FREE_TEXT(3),
  FREE_TEXT_CALL_OUT(4),
  STAMP(5),
  IMAGE(6),
  HIGHLIGHT(7),
  UNDERLINE(8),
  SQUIGGLY(9),
  STRIKE_OUT(10),
  LINE(11),
  ARROW(12),
  SQUARE(13),
  CIRCLE(14),
  POLYGON(15),
  POLYLINE(16),
  ERASER(17),
  CLOUDY(18),
  LINK(19),
  CARET(20),
  RICH_MEDIA(21),
  SCREEN(22),
  FILE(23),
  WIDGET(24),
  REDACTION(25),
  SIGNATURE(26),
  STAMP_IMAGE(27),
  NOTE(28),
  SOUND(29),
  MEASUREMENT_AREA_RECT(30),
  MEASUREMENT_AREA_POLYGON(31),
  MEASUREMENT_AREA_ELLIPSE(32),
  MEASUREMENT_PERIMETER(33),
  MEASUREMENT_DISTANCE(34);

  companion object {
    fun ofRaw(raw: Int): AnnotationTool? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class AnnotationToolVariant(val raw: Int) {
  INK_PEN(0),
  INK_MAGIC(1),
  INK_HIGHLIGHTER(2),
  FREE_TEXT(3),
  FREE_TEXT_CALL_OUT(4),
  STAMP(5),
  IMAGE(6),
  HIGHLIGHT(7),
  UNDERLINE(8);

  companion object {
    fun ofRaw(raw: Int): AnnotationToolVariant? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class AnnotationProcessingMode(val raw: Int) {
  FLATTEN(0),
  REMOVE(1),
  EMBED(2),
  PRINT(3);

  companion object {
    fun ofRaw(raw: Int): AnnotationProcessingMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class DocumentPermissions(val raw: Int) {
  /** Allow printing of document. */
  PRINTING(0),
  /** Modify the contents of the document. */
  MODIFICATION(1),
  /** Copy text and images from the document. */
  EXTRACT(2),
  /** Add or modify text annotations, fill in interactive form fields. */
  ANNOTATIONS_AND_FORMS(3),
  /** Fill in existing interactive form fields (including signature fields). */
  FILL_FORMS(4),
  /** Extract text and images from the document. */
  EXTRACT_ACCESSIBILITY(5),
  /** Assemble the document (insert, rotate, or delete pages and create document outline items or thumbnail images). */
  ASSEMBLE(6),
  /** Print high quality. */
  PRINT_HIGH_QUALITY(7);

  companion object {
    fun ofRaw(raw: Int): DocumentPermissions? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The PDF version of a document. */
enum class PdfVersion(val raw: Int) {
  PDF_1_0(0),
  PDF_1_1(1),
  PDF_1_2(2),
  PDF_1_3(3),
  PDF_1_4(4),
  PDF_1_5(5),
  PDF_1_6(6),
  PDF_1_7(7);

  companion object {
    fun ofRaw(raw: Int): PdfVersion? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PdfFormFieldTypes(val raw: Int) {
  TEXT(0),
  CHECKBOX(1),
  RADIO_BUTTON(2),
  COMBO_BOX(3),
  LIST_BOX(4),
  SIGNATURE(5),
  BUTTON(6),
  UNKNOWN(7);

  companion object {
    fun ofRaw(raw: Int): PdfFormFieldTypes? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class NutrientEvent(val raw: Int) {
  /** Event triggered when annotations are created. */
  ANNOTATIONS_CREATED(0),
  /** Event triggered when annotations are pressed. */
  ANNOTATIONS_DESELECTED(1),
  /** Event triggered when annotations are updated. */
  ANNOTATIONS_UPDATED(2),
  /** Event triggered when annotations are deleted. */
  ANNOTATIONS_DELETED(3),
  /** Event triggered when annotations are focused. */
  ANNOTATIONS_SELECTED(4),
  /** Event triggered when form field values are updated. */
  FORM_FIELD_VALUES_UPDATED(5),
  /** Event triggered when form fields are loaded. */
  FORM_FIELD_SELECTED(6),
  /** Event triggered when form fields are about to be saved. */
  FORM_FIELD_DESELECTED(7),
  /** Event triggered when text selection changes. */
  TEXT_SELECTION_CHANGED(8);

  companion object {
    fun ofRaw(raw: Int): NutrientEvent? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Enumeration of default annotation menu actions that can be removed or disabled.
 *
 * **Platform Support:**
 * - All actions can be removed or disabled on both iOS and Android
 * - Some system actions (copy/paste) may be harder to remove on iOS due to system restrictions
 */
enum class AnnotationMenuAction(val raw: Int) {
  /**
   * Delete action - removes the annotation
   * - iOS: Part of UIMenu system actions
   * - Android: R.id.pspdf__annotation_editing_toolbar_item_delete
   */
  DELETE(0),
  /**
   * Copy action - copies the annotation
   * - iOS: System copy action (may be harder to remove)
   * - Android: R.id.pspdf__annotation_editing_toolbar_item_copy
   */
  COPY(1),
  /**
   * Cut action - cuts the annotation to clipboard
   * - iOS: System cut action
   * - Android: R.id.pspdf__annotation_editing_toolbar_item_cut
   */
  CUT(2),
  /**
   * Color action - opens annotation color picker/inspector
   * - iOS: Style picker in UIMenu
   * - Android: R.id.pspdf__annotation_editing_toolbar_item_picker
   */
  COLOR(3),
  /**
   * Note action - opens annotation note editor
   * - iOS: Note action in UIMenu
   * - Android: R.id.pspdf__annotation_editing_toolbar_item_annotation_note
   */
  NOTE(4),
  /**
   * Undo action - undoes the last action
   * - iOS: Undo in UIMenu
   * - Android: R.id.pspdf__annotation_editing_toolbar_item_undo
   */
  UNDO(5),
  /**
   * Redo action - redoes the previously undone action
   * - iOS: Redo in UIMenu
   * - Android: R.id.pspdf__annotation_editing_toolbar_item_redo
   */
  REDO(6);

  companion object {
    fun ofRaw(raw: Int): AnnotationMenuAction? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PdfRect (
  val x: Double,
  val y: Double,
  val width: Double,
  val height: Double
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PdfRect {
      val x = pigeonVar_list[0] as Double
      val y = pigeonVar_list[1] as Double
      val width = pigeonVar_list[2] as Double
      val height = pigeonVar_list[3] as Double
      return PdfRect(x, y, width, height)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      x,
      y,
      width,
      height,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PageInfo (
  /** The index of the page. This is a zero-based index. */
  val pageIndex: Long,
  /** The height of the page in points. */
  val height: Double,
  /** The width of the page in points. */
  val width: Double,
  /** The rotation of the page in degrees. */
  val rotation: Long,
  /** The label of the page. */
  val label: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PageInfo {
      val pageIndex = pigeonVar_list[0] as Long
      val height = pigeonVar_list[1] as Double
      val width = pigeonVar_list[2] as Double
      val rotation = pigeonVar_list[3] as Long
      val label = pigeonVar_list[4] as String
      return PageInfo(pageIndex, height, width, rotation, label)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      pageIndex,
      height,
      width,
      rotation,
      label,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class DocumentSaveOptions (
  /** The password is used to encrypt the document. On Web, it's used as the user password. */
  val userPassword: String? = null,
  /** The owner password is used to encrypt the document and set permissions. It's only used on Web. */
  val ownerPassword: String? = null,
  /** Flatten annotations and form fields into the page content. */
  val flatten: Boolean? = null,
  /** Whether to save the document incrementally. */
  val incremental: Boolean? = null,
  /** The permissions to set on the document. See [DocumentPermissions] for more information. */
  val permissions: List<DocumentPermissions?>? = null,
  /** The PDF version to save the document as. */
  val pdfVersion: PdfVersion? = null,
  /** Whether to exclude annotations from the exported document. */
  val excludeAnnotations: Boolean? = null,
  /** Whether to exclude annotations that have the noPrint flag set to true from the exported document (Standalone only) */
  val saveForPrinting: Boolean? = null,
  /** Whether to include comments in the exported document (Server-Backed only). */
  val includeComments: Boolean? = null,
  /** Whether tp allow you to export a PDF in PDF/A format. */
  val outputFormat: Any? = null,
  /** Whether to optimize the document for the web. */
  val optimize: Boolean? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): DocumentSaveOptions {
      val userPassword = pigeonVar_list[0] as String?
      val ownerPassword = pigeonVar_list[1] as String?
      val flatten = pigeonVar_list[2] as Boolean?
      val incremental = pigeonVar_list[3] as Boolean?
      val permissions = pigeonVar_list[4] as List<DocumentPermissions?>?
      val pdfVersion = pigeonVar_list[5] as PdfVersion?
      val excludeAnnotations = pigeonVar_list[6] as Boolean?
      val saveForPrinting = pigeonVar_list[7] as Boolean?
      val includeComments = pigeonVar_list[8] as Boolean?
      val outputFormat = pigeonVar_list[9]
      val optimize = pigeonVar_list[10] as Boolean?
      return DocumentSaveOptions(userPassword, ownerPassword, flatten, incremental, permissions, pdfVersion, excludeAnnotations, saveForPrinting, includeComments, outputFormat, optimize)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      userPassword,
      ownerPassword,
      flatten,
      incremental,
      permissions,
      pdfVersion,
      excludeAnnotations,
      saveForPrinting,
      includeComments,
      outputFormat,
      optimize,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PdfFormOption (
  /** The value of the option. */
  val value: String,
  /** The label of the option. */
  val label: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PdfFormOption {
      val value = pigeonVar_list[0] as String
      val label = pigeonVar_list[1] as String
      return PdfFormOption(value, label)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      value,
      label,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class FormFieldData (
  val name: String,
  val alternativeFieldName: String? = null,
  val fullyQualifiedName: String? = null,
  val type: PdfFormFieldTypes,
  val annotations: Any? = null,
  val isReadOnly: Boolean? = null,
  val isRequired: Boolean? = null,
  val isExported: Boolean? = null,
  val isDirty: Boolean? = null,
  val options: List<PdfFormOption?>? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): FormFieldData {
      val name = pigeonVar_list[0] as String
      val alternativeFieldName = pigeonVar_list[1] as String?
      val fullyQualifiedName = pigeonVar_list[2] as String?
      val type = pigeonVar_list[3] as PdfFormFieldTypes
      val annotations = pigeonVar_list[4]
      val isReadOnly = pigeonVar_list[5] as Boolean?
      val isRequired = pigeonVar_list[6] as Boolean?
      val isExported = pigeonVar_list[7] as Boolean?
      val isDirty = pigeonVar_list[8] as Boolean?
      val options = pigeonVar_list[9] as List<PdfFormOption?>?
      return FormFieldData(name, alternativeFieldName, fullyQualifiedName, type, annotations, isReadOnly, isRequired, isExported, isDirty, options)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      name,
      alternativeFieldName,
      fullyQualifiedName,
      type,
      annotations,
      isReadOnly,
      isRequired,
      isExported,
      isDirty,
      options,
    )
  }
}

/**
 * Options for opening a document without a viewer (headless mode).
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class HeadlessDocumentOpenOptions (
  /** Password for encrypted documents. */
  val password: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): HeadlessDocumentOpenOptions {
      val password = pigeonVar_list[0] as String?
      return HeadlessDocumentOpenOptions(password)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      password,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PointF (
  val x: Double,
  val y: Double
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PointF {
      val x = pigeonVar_list[0] as Double
      val y = pigeonVar_list[1] as Double
      return PointF(x, y)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      x,
      y,
    )
  }
}

/**
 * Configuration data for annotation contextual menu
 *
 * This class defines how annotation menus should be configured
 * when displayed to users. It supports removing actions, disabling actions,
 * and controlling visual presentation options.
 *
 * **Usage Patterns**:
 * - **Static Configuration**: Set once via [NutrientViewController.setAnnotationMenuConfiguration]
 *
 * **Platform Compatibility**:
 * - [itemsToRemove]: Supported on Android, iOS, and Web
 * - [itemsToDisable]: Supported on Android, iOS, and Web
 * - [showStylePicker]: Supported on Android and iOS
 * - [groupMarkupItems]: iOS only (ignored on other platforms)
 * - [maxVisibleItems]: Platform-dependent behavior
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class AnnotationMenuConfigurationData (
  /**
   * List of default annotation menu actions to remove completely from the menu.
   *
   * These actions will not appear in the contextual menu at all.
   * Use this when you want to completely hide certain functionality.
   *
   * **Example**: Remove delete action for read-only annotations
   * ```dart
   * itemsToRemove: [AnnotationMenuAction.delete]
   * ```
   */
  val itemsToRemove: List<AnnotationMenuAction>,
  /**
   * List of default annotation menu actions to disable (show as grayed out).
   *
   * These actions will appear in the menu but will be non-interactive.
   * Use this when you want to show functionality exists but is temporarily unavailable.
   *
   * **Example**: Disable copy action for certain annotation types
   * ```dart
   * itemsToDisable: [AnnotationMenuAction.copy]
   * ```
   */
  val itemsToDisable: List<AnnotationMenuAction>,
  /**
   * Whether to show the platform's default style picker in the annotation menu.
   *
   * When true, users can access color, thickness, and other style options
   * directly from the annotation menu.
   *
   * **Platform Behavior**:
   * - **iOS**: Shows style picker as part of UIMenu
   * - **Android**: Shows annotation inspector/style picker
   * - **Web**: Shows color picker and basic style options
   */
  val showStylePicker: Boolean,
  /**
   * Whether to group markup annotation actions together in the menu.
   *
   * When true, related markup actions (highlight, underline, etc.) are
   * visually grouped in the menu for better organization.
   *
   * **Platform Support**: iOS only (ignored on Android and Web)
   */
  val groupMarkupItems: Boolean,
  /**
   * Maximum number of actions to show directly in the menu before creating overflow.
   *
   * When the number of available actions exceeds this limit, the platform
   * may create a submenu or overflow menu to accommodate additional actions.
   *
   * **Platform Behavior**:
   * - **iOS**: Respects platform UI guidelines for menu length
   * - **Android**: Limited by toolbar space and screen size
   * - **Web**: Creates scrollable or paginated menu as needed
   *
   * **Note**: If null, the platform default behavior is used.
   */
  val maxVisibleItems: Long? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): AnnotationMenuConfigurationData {
      val itemsToRemove = pigeonVar_list[0] as List<AnnotationMenuAction>
      val itemsToDisable = pigeonVar_list[1] as List<AnnotationMenuAction>
      val showStylePicker = pigeonVar_list[2] as Boolean
      val groupMarkupItems = pigeonVar_list[3] as Boolean
      val maxVisibleItems = pigeonVar_list[4] as Long?
      return AnnotationMenuConfigurationData(itemsToRemove, itemsToDisable, showStylePicker, groupMarkupItems, maxVisibleItems)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      itemsToRemove,
      itemsToDisable,
      showStylePicker,
      groupMarkupItems,
      maxVisibleItems,
    )
  }
}

/**
 * Data class for annotation properties that provides type-safe access
 * to annotation attributes while preserving attachments and custom data.
 *
 * This class is used with the AnnotationManager API to safely update
 * annotation properties without losing data during the update process.
 *
 * **Usage Pattern**:
 * ```dart
 * // Get current properties
 * final properties = await annotationManager.getAnnotationProperties(pageIndex, annotationId);
 *
 * // Create modified version
 * final updated = properties?.withColor(Colors.red).withOpacity(0.7);
 *
 * // Save changes
 * if (updated != null) {
 *   await annotationManager.saveAnnotationProperties(updated);
 * }
 * ```
 *
 * **Data Preservation**: Unlike the deprecated `updateAnnotation` method,
 * this approach preserves attachments, custom data, and other properties
 * that are not being explicitly modified.
 *
 * **Note on inkLines, customData, bbox, and flags**: These fields are serialized as JSON
 * strings internally to avoid Pigeon's CastList type casting issues. Use the
 * extension methods for typed access (e.g., `inkLines`, `customData`, `boundingBox`, `flagsSet`).
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class AnnotationProperties (
  /** Unique identifier for the annotation */
  val annotationId: String,
  /** Zero-based page index where the annotation is located */
  val pageIndex: Long,
  /** Stroke color as ARGB integer (e.g., 0xFFFF0000 for red) */
  val strokeColor: Long? = null,
  /** Fill color as ARGB integer (e.g., 0xFF0000FF for blue) */
  val fillColor: Long? = null,
  /** Opacity value between 0.0 (transparent) and 1.0 (opaque) */
  val opacity: Double? = null,
  /** Line width for stroke-based annotations (in points) */
  val lineWidth: Double? = null,
  /**
   * Annotation flags as a JSON string array (e.g., '["readOnly", "print"]').
   * Use the `flagsSet` getter from the extension for typed access as Set<AnnotationFlag>.
   */
  val flagsJson: String? = null,
  /**
   * Custom data associated with the annotation as a JSON string.
   * Use the `customData` getter from the extension for typed access.
   * This preserves any application-specific metadata.
   */
  val customDataJson: String? = null,
  /** Text content of the annotation (for text-based annotations) */
  val contents: String? = null,
  /** Subject/title of the annotation */
  val subject: String? = null,
  /** Creator/author of the annotation */
  val creator: String? = null,
  /**
   * Bounding box as a JSON string array [x, y, width, height] in PDF coordinates.
   * Use the `boundingBox` getter from the extension for typed access as Rect.
   */
  val bboxJson: String? = null,
  /** Note text associated with the annotation */
  val note: String? = null,
  /**
   * Ink lines for ink annotations as a JSON string.
   * Use the `inkLines` getter from the extension for typed access.
   * Format: [[[x, y, pressure], ...], ...]
   * Each line is an array of points, each point is [x, y, pressure].
   */
  val inkLinesJson: String? = null,
  /** Font name for text annotations */
  val fontName: String? = null,
  /** Font size for text annotations (in points) */
  val fontSize: Double? = null,
  /** Icon name for note annotations (e.g., 'Comment', 'Key', 'Note') */
  val iconName: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): AnnotationProperties {
      val annotationId = pigeonVar_list[0] as String
      val pageIndex = pigeonVar_list[1] as Long
      val strokeColor = pigeonVar_list[2] as Long?
      val fillColor = pigeonVar_list[3] as Long?
      val opacity = pigeonVar_list[4] as Double?
      val lineWidth = pigeonVar_list[5] as Double?
      val flagsJson = pigeonVar_list[6] as String?
      val customDataJson = pigeonVar_list[7] as String?
      val contents = pigeonVar_list[8] as String?
      val subject = pigeonVar_list[9] as String?
      val creator = pigeonVar_list[10] as String?
      val bboxJson = pigeonVar_list[11] as String?
      val note = pigeonVar_list[12] as String?
      val inkLinesJson = pigeonVar_list[13] as String?
      val fontName = pigeonVar_list[14] as String?
      val fontSize = pigeonVar_list[15] as Double?
      val iconName = pigeonVar_list[16] as String?
      return AnnotationProperties(annotationId, pageIndex, strokeColor, fillColor, opacity, lineWidth, flagsJson, customDataJson, contents, subject, creator, bboxJson, note, inkLinesJson, fontName, fontSize, iconName)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      annotationId,
      pageIndex,
      strokeColor,
      fillColor,
      opacity,
      lineWidth,
      flagsJson,
      customDataJson,
      contents,
      subject,
      creator,
      bboxJson,
      note,
      inkLinesJson,
      fontName,
      fontSize,
      iconName,
    )
  }
}

/**
 * Represents a bookmark in a PDF document.
 *
 * Bookmarks are user-created markers that allow quick navigation
 * to specific pages or actions in a document. They are different from
 * PDF outlines (table of contents).
 *
 * This follows the Instant JSON bookmark specification:
 * - `type` is always "pspdfkit/bookmark"
 * - `action` defines what happens when the bookmark is activated
 * - `name` provides a display label
 *
 * Example usage:
 * ```dart
 * // Create a bookmark for page 5
 * final bookmark = Bookmark.forPage(pageIndex: 5, name: 'Chapter 2');
 * await document.addBookmark(bookmark);
 *
 * // Get all bookmarks
 * final bookmarks = await document.getBookmarks();
 * ```
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class Bookmark (
  /**
   * The PDF bookmark ID used to store the bookmark in the PDF.
   * This is assigned by the system when the bookmark is persisted.
   * May be null for newly created bookmarks.
   */
  val pdfBookmarkId: String? = null,
  /**
   * Display name of the bookmark shown in the UI.
   * If not provided, a default name based on the page number may be used.
   */
  val name: String? = null,
  /**
   * The action JSON string defining what happens when the bookmark is activated.
   * Typically a GoToAction that navigates to a specific page.
   * Format: {"type": "goTo", "pageIndex": 0, "destinationType": "fitPage"}
   */
  val actionJson: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): Bookmark {
      val pdfBookmarkId = pigeonVar_list[0] as String?
      val name = pigeonVar_list[1] as String?
      val actionJson = pigeonVar_list[2] as String?
      return Bookmark(pdfBookmarkId, name, actionJson)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      pdfBookmarkId,
      name,
      actionJson,
    )
  }
}
private open class NutrientApiPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AndroidPermissionStatus.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AnnotationType.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AnnotationTool.ofRaw(it.toInt())
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AnnotationToolVariant.ofRaw(it.toInt())
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AnnotationProcessingMode.ofRaw(it.toInt())
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          DocumentPermissions.ofRaw(it.toInt())
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PdfVersion.ofRaw(it.toInt())
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PdfFormFieldTypes.ofRaw(it.toInt())
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          NutrientEvent.ofRaw(it.toInt())
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AnnotationMenuAction.ofRaw(it.toInt())
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PdfRect.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PageInfo.fromList(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          DocumentSaveOptions.fromList(it)
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PdfFormOption.fromList(it)
        }
      }
      143.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FormFieldData.fromList(it)
        }
      }
      144.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          HeadlessDocumentOpenOptions.fromList(it)
        }
      }
      145.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointF.fromList(it)
        }
      }
      146.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AnnotationMenuConfigurationData.fromList(it)
        }
      }
      147.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AnnotationProperties.fromList(it)
        }
      }
      148.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Bookmark.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is AndroidPermissionStatus -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is AnnotationType -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is AnnotationTool -> {
        stream.write(131)
        writeValue(stream, value.raw)
      }
      is AnnotationToolVariant -> {
        stream.write(132)
        writeValue(stream, value.raw)
      }
      is AnnotationProcessingMode -> {
        stream.write(133)
        writeValue(stream, value.raw)
      }
      is DocumentPermissions -> {
        stream.write(134)
        writeValue(stream, value.raw)
      }
      is PdfVersion -> {
        stream.write(135)
        writeValue(stream, value.raw)
      }
      is PdfFormFieldTypes -> {
        stream.write(136)
        writeValue(stream, value.raw)
      }
      is NutrientEvent -> {
        stream.write(137)
        writeValue(stream, value.raw)
      }
      is AnnotationMenuAction -> {
        stream.write(138)
        writeValue(stream, value.raw)
      }
      is PdfRect -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is PageInfo -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is DocumentSaveOptions -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      is PdfFormOption -> {
        stream.write(142)
        writeValue(stream, value.toList())
      }
      is FormFieldData -> {
        stream.write(143)
        writeValue(stream, value.toList())
      }
      is HeadlessDocumentOpenOptions -> {
        stream.write(144)
        writeValue(stream, value.toList())
      }
      is PointF -> {
        stream.write(145)
        writeValue(stream, value.toList())
      }
      is AnnotationMenuConfigurationData -> {
        stream.write(146)
        writeValue(stream, value.toList())
      }
      is AnnotationProperties -> {
        stream.write(147)
        writeValue(stream, value.toList())
      }
      is Bookmark -> {
        stream.write(148)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/**
 * The API for interacting with a PDF document.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface NutrientApi {
  fun getFrameworkVersion(callback: (Result<String?>) -> Unit)
  fun setLicenseKey(licenseKey: String?, callback: (Result<Unit>) -> Unit)
  fun setLicenseKeys(androidLicenseKey: String?, iOSLicenseKey: String?, webLicenseKey: String?, callback: (Result<Unit>) -> Unit)
  fun present(document: String, configuration: Map<String, Any>?, callback: (Result<Boolean?>) -> Unit)
  fun presentInstant(serverUrl: String, jwt: String, configuration: Map<String, Any>?, callback: (Result<Boolean?>) -> Unit)
  fun setFormFieldValue(value: String, fullyQualifiedName: String, callback: (Result<Boolean?>) -> Unit)
  fun getFormFieldValue(fullyQualifiedName: String, callback: (Result<String?>) -> Unit)
  fun applyInstantJson(annotationsJson: String, callback: (Result<Boolean?>) -> Unit)
  fun exportInstantJson(callback: (Result<String?>) -> Unit)
  fun addAnnotation(annotation: String, attachment: String?, callback: (Result<Boolean?>) -> Unit)
  fun removeAnnotation(annotation: String, callback: (Result<Boolean?>) -> Unit)
  /**
   * Returns a JSON string containing an array of annotation objects for the given `type` on the given `pageIndex`.
   * The JSON string can be decoded to List<Map<String, dynamic>> on the Dart side.
   * Using JSON string avoids Pigeon's CastList issues with nested types in release mode.
   */
  fun getAnnotationsJson(pageIndex: Long, type: String, callback: (Result<String?>) -> Unit)
  /**
   * Returns a JSON string containing all unsaved annotations in the presented document.
   * The JSON string can be decoded to the appropriate type on the Dart side.
   * Using JSON string avoids Pigeon's CastList issues with nested types in release mode.
   */
  fun getAllUnsavedAnnotationsJson(callback: (Result<String?>) -> Unit)
  fun updateAnnotation(annotation: String, callback: (Result<Unit>) -> Unit)
  fun processAnnotations(type: AnnotationType, processingMode: AnnotationProcessingMode, destinationPath: String, callback: (Result<Boolean?>) -> Unit)
  fun importXfdf(xfdfString: String, callback: (Result<Boolean?>) -> Unit)
  fun exportXfdf(xfdfPath: String, callback: (Result<Boolean?>) -> Unit)
  fun save(callback: (Result<Boolean?>) -> Unit)
  fun setDelayForSyncingLocalChanges(delay: Double, callback: (Result<Boolean?>) -> Unit)
  fun setListenToServerChanges(listen: Boolean, callback: (Result<Boolean?>) -> Unit)
  fun syncAnnotations(callback: (Result<Boolean?>) -> Unit)
  fun checkAndroidWriteExternalStoragePermission(callback: (Result<Boolean?>) -> Unit)
  fun requestAndroidWriteExternalStoragePermission(callback: (Result<AndroidPermissionStatus>) -> Unit)
  fun openAndroidSettings(callback: (Result<Unit>) -> Unit)
  fun setAnnotationPresetConfigurations(configurations: Map<String, Any?>, callback: (Result<Boolean?>) -> Unit)
  fun getTemporaryDirectory(callback: (Result<String>) -> Unit)
  fun setAuthorName(name: String, callback: (Result<Unit>) -> Unit)
  fun getAuthorName(callback: (Result<String>) -> Unit)
  /**
   * Generate PDF from Images, Template, and Patterns.
   * [pages]: [NewPage]s to be added to the PDF.
   * [outputPath]: The path to the output file.
   * Returns the path to the generated PDF path or null if the input is invalid or if the PDF generation fails.
   */
  fun generatePdf(pages: List<Map<String, Any>>, outputPath: String, callback: (Result<String?>) -> Unit)
  /**
   * Generates a PDF from HTML string.
   *
   * [html]: The HTML string to be converted to PDF.
   * [outPutFile]: The path to the output file.
   * Returns the path to the generated PDF file or null if the input is invalid or if the PDF generation fails.
   */
  fun generatePdfFromHtmlString(html: String, outPutFile: String, options: Map<String, Any>?, callback: (Result<String?>) -> Unit)
  fun generatePdfFromHtmlUri(htmlUri: String, outPutFile: String, options: Map<String, Any>?, callback: (Result<String?>) -> Unit)
  /** Configure Nutrient Analytics events. */
  fun enableAnalyticsEvents(enable: Boolean)
  /**
   * Sets the annotation menu configuration for the global presenter.
   * This configuration applies to all annotation menus in presented documents.
   *
   * @param configuration The annotation menu configuration to apply.
   * @return True if the configuration was set successfully, false otherwise.
   */
  fun setAnnotationMenuConfiguration(configuration: AnnotationMenuConfigurationData, callback: (Result<Boolean?>) -> Unit)

  companion object {
    /** The codec used by NutrientApi. */
    val codec: MessageCodec<Any?> by lazy {
      NutrientApiPigeonCodec()
    }
    /** Sets up an instance of `NutrientApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: NutrientApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.getFrameworkVersion$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getFrameworkVersion{ result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setLicenseKey$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val licenseKeyArg = args[0] as String?
            api.setLicenseKey(licenseKeyArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setLicenseKeys$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val androidLicenseKeyArg = args[0] as String?
            val iOSLicenseKeyArg = args[1] as String?
            val webLicenseKeyArg = args[2] as String?
            api.setLicenseKeys(androidLicenseKeyArg, iOSLicenseKeyArg, webLicenseKeyArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.present$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val documentArg = args[0] as String
            val configurationArg = args[1] as Map<String, Any>?
            api.present(documentArg, configurationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.presentInstant$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val serverUrlArg = args[0] as String
            val jwtArg = args[1] as String
            val configurationArg = args[2] as Map<String, Any>?
            api.presentInstant(serverUrlArg, jwtArg, configurationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setFormFieldValue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val valueArg = args[0] as String
            val fullyQualifiedNameArg = args[1] as String
            api.setFormFieldValue(valueArg, fullyQualifiedNameArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.getFormFieldValue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val fullyQualifiedNameArg = args[0] as String
            api.getFormFieldValue(fullyQualifiedNameArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.applyInstantJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val annotationsJsonArg = args[0] as String
            api.applyInstantJson(annotationsJsonArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.exportInstantJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.exportInstantJson{ result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.addAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val annotationArg = args[0] as String
            val attachmentArg = args[1] as String?
            api.addAnnotation(annotationArg, attachmentArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.removeAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val annotationArg = args[0] as String
            api.removeAnnotation(annotationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.getAnnotationsJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val typeArg = args[1] as String
            api.getAnnotationsJson(pageIndexArg, typeArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.getAllUnsavedAnnotationsJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getAllUnsavedAnnotationsJson{ result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.updateAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val annotationArg = args[0] as String
            api.updateAnnotation(annotationArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.processAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val typeArg = args[0] as AnnotationType
            val processingModeArg = args[1] as AnnotationProcessingMode
            val destinationPathArg = args[2] as String
            api.processAnnotations(typeArg, processingModeArg, destinationPathArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.importXfdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfStringArg = args[0] as String
            api.importXfdf(xfdfStringArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.exportXfdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfPathArg = args[0] as String
            api.exportXfdf(xfdfPathArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.save$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.save{ result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setDelayForSyncingLocalChanges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val delayArg = args[0] as Double
            api.setDelayForSyncingLocalChanges(delayArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setListenToServerChanges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val listenArg = args[0] as Boolean
            api.setListenToServerChanges(listenArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.syncAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.syncAnnotations{ result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.checkAndroidWriteExternalStoragePermission$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.checkAndroidWriteExternalStoragePermission{ result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.requestAndroidWriteExternalStoragePermission$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.requestAndroidWriteExternalStoragePermission{ result: Result<AndroidPermissionStatus> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.openAndroidSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.openAndroidSettings{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setAnnotationPresetConfigurations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val configurationsArg = args[0] as Map<String, Any?>
            api.setAnnotationPresetConfigurations(configurationsArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.getTemporaryDirectory$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getTemporaryDirectory{ result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setAuthorName$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val nameArg = args[0] as String
            api.setAuthorName(nameArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.getAuthorName$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getAuthorName{ result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.generatePdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pagesArg = args[0] as List<Map<String, Any>>
            val outputPathArg = args[1] as String
            api.generatePdf(pagesArg, outputPathArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.generatePdfFromHtmlString$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val htmlArg = args[0] as String
            val outPutFileArg = args[1] as String
            val optionsArg = args[2] as Map<String, Any>?
            api.generatePdfFromHtmlString(htmlArg, outPutFileArg, optionsArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.generatePdfFromHtmlUri$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val htmlUriArg = args[0] as String
            val outPutFileArg = args[1] as String
            val optionsArg = args[2] as Map<String, Any>?
            api.generatePdfFromHtmlUri(htmlUriArg, outPutFileArg, optionsArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.enableAnalyticsEvents$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enableArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.enableAnalyticsEvents(enableArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setAnnotationMenuConfiguration$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val configurationArg = args[0] as AnnotationMenuConfigurationData
            api.setAnnotationMenuConfiguration(configurationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class NutrientApiCallbacks(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by NutrientApiCallbacks. */
    val codec: MessageCodec<Any?> by lazy {
      NutrientApiPigeonCodec()
    }
  }
  /** onPAuse callback for FlutterPdfActivity */
  fun onPdfActivityOnPause(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onPdfActivityOnPause$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onPdfFragmentAdded(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onPdfFragmentAdded$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onDocumentLoaded(documentIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onDocumentLoaded$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** ViewControllerWillDismiss callback for PDFViewController */
  fun onPdfViewControllerWillDismiss(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onPdfViewControllerWillDismiss$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** ViewControllerDidDismiss callback for PDFViewController */
  fun onPdfViewControllerDidDismiss(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onPdfViewControllerDidDismiss$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when instant synchronization starts. */
  fun onInstantSyncStarted(documentIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncStarted$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when instant synchronization ends. */
  fun onInstantSyncFinished(documentIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncFinished$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when instant synchronization fails. */
  fun onInstantSyncFailed(documentIdArg: String, errorArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncFailed$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when instant authentication is done. */
  fun onInstantAuthenticationFinished(documentIdArg: String, validJWTArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantAuthenticationFinished$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, validJWTArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when instant authentication fails. */
  fun onInstantAuthenticationFailed(documentIdArg: String, errorArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantAuthenticationFailed$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Only available on iOS.
   * Called when instant document download is done.
   */
  fun onInstantDownloadFinished(documentIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantDownloadFinished$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Only available on iOS.
   * Called when instant document download fails.
   */
  fun onInstantDownloadFailed(documentIdArg: String, errorArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantDownloadFailed$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface NutrientViewControllerApi {
  /**
   * Sets the value of a form field by specifying its fully qualified field name.
   * This method is deprecated. Use [PdfDocument.setFormFieldValue] instead.
   */
  fun setFormFieldValue(value: String, fullyQualifiedName: String, callback: (Result<Boolean?>) -> Unit)
  /** Gets the form field value by specifying its fully qualified name. */
  fun getFormFieldValue(fullyQualifiedName: String, callback: (Result<String?>) -> Unit)
  /** Applies Instant document JSON to the presented document. */
  fun applyInstantJson(annotationsJson: String, callback: (Result<Boolean?>) -> Unit)
  /** Exports Instant document JSON from the presented document. */
  fun exportInstantJson(callback: (Result<String?>) -> Unit)
  /**
   * Adds the given annotation to the presented document.
   * `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
   */
  fun addAnnotation(annotation: String, callback: (Result<Boolean?>) -> Unit)
  /**
   * Removes the given annotation from the presented document.
   * `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
   */
  fun removeAnnotation(annotation: String, callback: (Result<Boolean?>) -> Unit)
  /**
   * Returns a JSON string containing an array of annotation objects for the given `type` on the given `pageIndex`.
   * The JSON string can be decoded to List<Map<String, dynamic>> on the Dart side.
   * Using JSON string avoids Pigeon's CastList issues with nested types in release mode.
   */
  fun getAnnotationsJson(pageIndex: Long, type: String, callback: (Result<String>) -> Unit)
  /**
   * Returns a JSON string containing all unsaved annotations in the presented document.
   * The JSON string can be decoded to the appropriate type on the Dart side.
   * Using JSON string avoids Pigeon's CastList issues with nested types in release mode.
   */
  fun getAllUnsavedAnnotationsJson(callback: (Result<String>) -> Unit)
  /**
   * Processes annotations of the given type with the provided processing
   * mode and stores the PDF at the given destination path.
   */
  fun processAnnotations(type: AnnotationType, processingMode: AnnotationProcessingMode, destinationPath: String, callback: (Result<Boolean>) -> Unit)
  /** Imports annotations from the XFDF file at the given path. */
  fun importXfdf(xfdfString: String, callback: (Result<Boolean>) -> Unit)
  /** Exports annotations to the XFDF file at the given path. */
  fun exportXfdf(xfdfPath: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Saves the document back to its original location if it has been changed.
   * If there were no changes to the document, the document file will not be modified.
   */
  fun save(callback: (Result<Boolean>) -> Unit)
  /**
   * Sets the annotation preset configurations for the given annotation tools.
   * @param configurations A map of annotation tools and their corresponding configurations.
   * @param modifyAssociatedAnnotations Whether to modify the annotations associated with the old configuration. Only used for Android.
   * @return True if the configurations were set successfully, false otherwise.
   */
  fun setAnnotationConfigurations(configurations: Map<String, Map<String, Any>>, callback: (Result<Boolean?>) -> Unit)
  /**
   * Gets the visible rect of the given page.
   * pageIndex The index of the page. This is a zero-based index.
   * Returns a [Future] that completes with the visible rect of the given page.
   */
  fun getVisibleRect(pageIndex: Long, callback: (Result<PdfRect>) -> Unit)
  /**
   * Zooms to the given rect on the given page.
   * pageIndex The index of the page. This is a zero-based index.
   * rect The rect to zoom to.
   * Returns a [Future] that completes when the zoom operation is done.
   */
  fun zoomToRect(pageIndex: Long, rect: PdfRect, animated: Boolean?, duration: Double?, callback: (Result<Boolean>) -> Unit)
  /**
   * Gets the zoom scale of the given page.
   * pageIndex The index of the page. This is a zero-based index.
   * Returns a [Future] that completes with the zoom scale of the given page.
   */
  fun getZoomScale(pageIndex: Long, callback: (Result<Double>) -> Unit)
  fun addEventListener(event: NutrientEvent)
  fun removeEventListener(event: NutrientEvent)
  /**
   * Enters annotation creation mode.
   *
   * If [annotationTool] is provided, that specific tool will be activated.
   * If no tool is provided, the default annotation tool will be used.
   *
   * Returns a [Future] that completes with a boolean indicating whether
   * entering annotation creation mode was successful.
   */
  fun enterAnnotationCreationMode(annotationTool: AnnotationTool?, callback: (Result<Boolean?>) -> Unit)
  /**
   * Exits annotation creation mode.
   *
   * Returns a [Future] that completes with a boolean indicating whether
   * exiting annotation creation mode was successful.
   */
  fun exitAnnotationCreationMode(callback: (Result<Boolean?>) -> Unit)
  /**
   * Sets the annotation menu configuration for the current view controller.
   * This configuration applies only to annotation menus in the current document view.
   *
   * @param configuration The annotation menu configuration to apply.
   * @return True if the configuration was set successfully, false otherwise.
   */
  fun setAnnotationMenuConfiguration(configuration: AnnotationMenuConfigurationData, callback: (Result<Boolean?>) -> Unit)

  companion object {
    /** The codec used by NutrientViewControllerApi. */
    val codec: MessageCodec<Any?> by lazy {
      NutrientApiPigeonCodec()
    }
    /** Sets up an instance of `NutrientViewControllerApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: NutrientViewControllerApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.setFormFieldValue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val valueArg = args[0] as String
            val fullyQualifiedNameArg = args[1] as String
            api.setFormFieldValue(valueArg, fullyQualifiedNameArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getFormFieldValue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val fullyQualifiedNameArg = args[0] as String
            api.getFormFieldValue(fullyQualifiedNameArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.applyInstantJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val annotationsJsonArg = args[0] as String
            api.applyInstantJson(annotationsJsonArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.exportInstantJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.exportInstantJson{ result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.addAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val annotationArg = args[0] as String
            api.addAnnotation(annotationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.removeAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val annotationArg = args[0] as String
            api.removeAnnotation(annotationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getAnnotationsJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val typeArg = args[1] as String
            api.getAnnotationsJson(pageIndexArg, typeArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getAllUnsavedAnnotationsJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getAllUnsavedAnnotationsJson{ result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.processAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val typeArg = args[0] as AnnotationType
            val processingModeArg = args[1] as AnnotationProcessingMode
            val destinationPathArg = args[2] as String
            api.processAnnotations(typeArg, processingModeArg, destinationPathArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.importXfdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfStringArg = args[0] as String
            api.importXfdf(xfdfStringArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.exportXfdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfPathArg = args[0] as String
            api.exportXfdf(xfdfPathArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.save$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.save{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.setAnnotationConfigurations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val configurationsArg = args[0] as Map<String, Map<String, Any>>
            api.setAnnotationConfigurations(configurationsArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getVisibleRect$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            api.getVisibleRect(pageIndexArg) { result: Result<PdfRect> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.zoomToRect$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val rectArg = args[1] as PdfRect
            val animatedArg = args[2] as Boolean?
            val durationArg = args[3] as Double?
            api.zoomToRect(pageIndexArg, rectArg, animatedArg, durationArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getZoomScale$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            api.getZoomScale(pageIndexArg) { result: Result<Double> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.addEventListener$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val eventArg = args[0] as NutrientEvent
            val wrapped: List<Any?> = try {
              api.addEventListener(eventArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.removeEventListener$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val eventArg = args[0] as NutrientEvent
            val wrapped: List<Any?> = try {
              api.removeEventListener(eventArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.enterAnnotationCreationMode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val annotationToolArg = args[0] as AnnotationTool?
            api.enterAnnotationCreationMode(annotationToolArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.exitAnnotationCreationMode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.exitAnnotationCreationMode{ result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.setAnnotationMenuConfiguration$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val configurationArg = args[0] as AnnotationMenuConfigurationData
            api.setAnnotationMenuConfiguration(configurationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface PdfDocumentApi {
  /**
   * Returns the page info for the given page index.
   * pageIndex The index of the page. This is a zero-based index.
   */
  fun getPageInfo(pageIndex: Long, callback: (Result<PageInfo>) -> Unit)
  /**
   * Exports the document as a PDF.
   * options:[DocumentSaveOptions] The options to use when exporting the document.
   * Returns a [Uint8List] containing the exported PDF data.
   */
  fun exportPdf(options: DocumentSaveOptions?, callback: (Result<ByteArray>) -> Unit)
  /**
   * Returns the form field with the given name as a JSON string.
   * The JSON string contains the form field data that can be decoded
   * to a Map<String, dynamic> on the Dart side.
   * Using JSON string avoids Pigeon's CastList issues with nested types.
   */
  fun getFormFieldJson(fieldName: String, callback: (Result<String>) -> Unit)
  /**
   * Returns a list of all form fields in the document as a JSON string.
   * The JSON string contains an array of form field objects that can be
   * decoded to List<Map<String, dynamic>> on the Dart side.
   * Using JSON string avoids Pigeon's CastList issues with nested types.
   */
  fun getFormFieldsJson(callback: (Result<String>) -> Unit)
  /** Sets the value of a form field by specifying its fully qualified field name. */
  fun setFormFieldValue(value: String, fullyQualifiedName: String, callback: (Result<Boolean?>) -> Unit)
  /** Gets the form field value by specifying its fully qualified name. */
  fun getFormFieldValue(fullyQualifiedName: String, callback: (Result<String?>) -> Unit)
  /** Applies Instant document JSON to the presented document. */
  fun applyInstantJson(annotationsJson: String, callback: (Result<Boolean?>) -> Unit)
  /** Exports Instant document JSON from the presented document. */
  fun exportInstantJson(callback: (Result<String?>) -> Unit)
  /**
   * Adds the given annotation to the presented document.
   * `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
   */
  fun addAnnotation(jsonAnnotation: String, attachment: Any?, callback: (Result<Boolean?>) -> Unit)
  /**
   * Updates the given annotation in the presented document.
   * `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
   *
   * @deprecated Use setAnnotationProperties() or specific property setters instead.
   * This method has a critical bug that causes data loss for annotations with attachments.
   * It will be removed in version 7.0.0.
   *
   * Migration:
   * - For single property updates: Use specific setters like setAnnotationColor()
   * - For multiple property updates: Use setAnnotationProperties()
   */
  fun updateAnnotation(jsonAnnotation: String, callback: (Result<Boolean?>) -> Unit)
  /**
   * Removes the given annotation from the presented document.
   * `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
   */
  fun removeAnnotation(jsonAnnotation: String, callback: (Result<Boolean?>) -> Unit)
  /**
   * Returns a JSON string containing an array of annotation objects for the given `type` on the given `pageIndex`.
   * The JSON string can be decoded to List<Map<String, dynamic>> on the Dart side.
   * Using JSON string avoids Pigeon's CastList issues with nested types in release mode.
   *
   * For annotations with attachments (image, stamp, file), the response includes an `attachment` object
   * containing `binary` (base64-encoded) and `contentType` fields, enabling complete annotation copying.
   */
  fun getAnnotationsJson(pageIndex: Long, type: String, callback: (Result<String>) -> Unit)
  /**
   * Returns a JSON string containing all unsaved annotations in the presented document.
   * The JSON string can be decoded to the appropriate type on the Dart side.
   * Using JSON string avoids Pigeon's CastList issues with nested types in release mode.
   */
  fun getAllUnsavedAnnotationsJson(callback: (Result<String>) -> Unit)
  /** Imports annotations from the XFDF file at the given path. */
  fun importXfdf(xfdfString: String, callback: (Result<Boolean>) -> Unit)
  /** Exports annotations to the XFDF file at the given path. */
  fun exportXfdf(xfdfPath: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Saves the document back to its original location if it has been changed.
   * If there were no changes to the document, the document file will not be modified.
   */
  fun save(outputPath: String?, options: DocumentSaveOptions?, callback: (Result<Boolean>) -> Unit)
  /** Get the total number of pages in the document. */
  fun getPageCount(callback: (Result<Long>) -> Unit)
  /**
   * Processes annotations of the given type with the provided processing
   * mode and stores the PDF at the given destination path.
   *
   * This method works for both viewer-bound and headless documents.
   *
   * @param type The type of annotations to process (e.g., all, ink, highlight)
   * @param processingMode The processing mode (flatten, embed, remove, print)
   * @param destinationPath The path where the processed PDF should be saved
   * @return true if processing succeeded, false otherwise
   */
  fun processAnnotations(type: AnnotationType, processingMode: AnnotationProcessingMode, destinationPath: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Closes the document and releases all native resources.
   *
   * This must be called when a headless document is no longer needed
   * to free memory and file handles. For viewer-bound documents,
   * this is handled automatically by the view lifecycle.
   *
   * @return true if the document was closed successfully
   */
  fun closeDocument(callback: (Result<Boolean>) -> Unit)
  /**
   * **iOS only.** Checks if the document has any dirty (unsaved) annotations.
   *
   * Maps directly to `document.hasDirtyAnnotations` in PSPDFKit iOS SDK.
   * Returns true if any annotations have been added, modified, or deleted
   * since the document was loaded or last saved.
   *
   * **Platform support:**
   * - iOS: â Supported
   * - Android: â Use `androidHasUnsavedAnnotationChanges()` instead
   * - Web: â Use `webHasUnsavedChanges()` instead
   *
   * @return true if there are dirty annotations
   * @throws On Android/Web
   */
  fun iOSHasDirtyAnnotations(callback: (Result<Boolean>) -> Unit)
  /**
   * **iOS only.** Gets the dirty state of a specific annotation.
   *
   * Maps directly to `annotation.isDirty` property in PSPDFKit iOS SDK.
   * An annotation is dirty if it has been modified since the document
   * was loaded or last saved.
   *
   * **Platform support:**
   * - iOS: â Supported
   * - Android: â Not available (no annotation-level isDirty)
   * - Web: â Not available
   *
   * @param pageIndex Zero-based page index
   * @param annotationId The annotation's unique identifier
   * @return true if the annotation is dirty
   * @throws On Android/Web, or if annotation not found
   */
  fun iOSGetAnnotationIsDirty(pageIndex: Long, annotationId: String, callback: (Result<Boolean>) -> Unit)
  /**
   * **iOS only.** Sets the dirty state of a specific annotation.
   *
   * Maps directly to setting `annotation.isDirty` property in PSPDFKit iOS SDK.
   * This can be used to manually mark an annotation as needing save,
   * or to clear its dirty state.
   *
   * **Platform support:**
   * - iOS: â Supported
   * - Android: â Not available
   * - Web: â Not available
   *
   * @param pageIndex Zero-based page index
   * @param annotationId The annotation's unique identifier
   * @param isDirty The dirty state to set
   * @return true if successfully set
   * @throws On Android/Web, or if annotation not found
   */
  fun iOSSetAnnotationIsDirty(pageIndex: Long, annotationId: String, isDirty: Boolean, callback: (Result<Boolean>) -> Unit)
  /**
   * **iOS only.** Clears the needs-save flag on all annotation providers.
   *
   * Maps directly to `containerProvider.clearNeedsSaveFlag()` in PSPDFKit iOS SDK.
   * This resets the modification tracking without saving to disk.
   *
   * **Platform support:**
   * - iOS: â Supported
   * - Android: â Not available (was removed from SDK)
   * - Web: â Not available
   *
   * @return true if successfully cleared
   * @throws On Android/Web
   */
  fun iOSClearNeedsSaveFlag(callback: (Result<Boolean>) -> Unit)
  /**
   * **Android only.** Checks if the annotation provider has unsaved changes.
   *
   * Maps directly to `annotationProvider.hasUnsavedChanges()` in PSPDFKit Android SDK.
   *
   * **Platform support:**
   * - iOS: â Use `iOSHasDirtyAnnotations()` instead
   * - Android: â Supported
   * - Web: â Use `webHasUnsavedChanges()` instead
   *
   * @return true if there are unsaved annotation changes
   * @throws On iOS/Web
   */
  fun androidHasUnsavedAnnotationChanges(callback: (Result<Boolean>) -> Unit)
  /**
   * **Android only.** Checks if the form provider has unsaved changes.
   *
   * Maps directly to `formProvider.hasUnsavedChanges()` in PSPDFKit Android SDK.
   *
   * **Platform support:**
   * - iOS: â Not available at provider level
   * - Android: â Supported
   * - Web: â Not available
   *
   * @return true if there are unsaved form field changes
   * @throws On iOS/Web
   */
  fun androidHasUnsavedFormChanges(callback: (Result<Boolean>) -> Unit)
  /**
   * **Android only.** Checks if the bookmark provider has unsaved changes.
   *
   * Maps directly to `bookmarkProvider.hasUnsavedChanges()` in PSPDFKit Android SDK.
   *
   * **Platform support:**
   * - iOS: â Not available at provider level
   * - Android: â Supported
   * - Web: â Not available
   *
   * @return true if there are unsaved bookmark changes
   * @throws On iOS/Web
   */
  fun androidHasUnsavedBookmarkChanges(callback: (Result<Boolean>) -> Unit)
  /**
   * **Android only.** Gets the dirty state of a specific bookmark.
   *
   * Maps directly to `bookmark.isDirty()` in PSPDFKit Android SDK.
   *
   * **Platform support:**
   * - iOS: â Not available
   * - Android: â Supported
   * - Web: â Not available
   *
   * @param bookmarkId The bookmark's identifier (pdfBookmarkId or name)
   * @return true if the bookmark is dirty
   * @throws On iOS/Web, or if bookmark not found
   */
  fun androidGetBookmarkIsDirty(bookmarkId: String, callback: (Result<Boolean>) -> Unit)
  /**
   * **Android only.** Clears the dirty state of a specific bookmark.
   *
   * Maps directly to `bookmark.clearDirty()` in PSPDFKit Android SDK.
   *
   * **Platform support:**
   * - iOS: â Not available
   * - Android: â Supported
   * - Web: â Not available
   *
   * @param bookmarkId The bookmark's identifier (pdfBookmarkId or name)
   * @return true if successfully cleared
   * @throws On iOS/Web, or if bookmark not found
   */
  fun androidClearBookmarkDirtyState(bookmarkId: String, callback: (Result<Boolean>) -> Unit)
  /**
   * **Android only.** Gets the dirty state of a form field.
   *
   * Maps directly to `formField.isDirty()` in PSPDFKit Android SDK.
   *
   * **Platform support:**
   * - iOS: â Not available (use formField.dirty property differently)
   * - Android: â Supported
   * - Web: â Not available
   *
   * @param fullyQualifiedName The form field's fully qualified name
   * @return true if the form field is dirty
   * @throws On iOS/Web, or if form field not found
   */
  fun androidGetFormFieldIsDirty(fullyQualifiedName: String, callback: (Result<Boolean>) -> Unit)
  /**
   * **Web only.** Checks if the instance has unsaved changes.
   *
   * Maps directly to `instance.hasUnsavedChanges()` in Nutrient Web SDK.
   * This is a combined check that includes annotations, forms, and other changes.
   *
   * **Platform support:**
   * - iOS: â Use `iOSHasDirtyAnnotations()` instead
   * - Android: â Use `androidHasUnsavedAnnotationChanges()` etc. instead
   * - Web: â Supported
   *
   * @return true if there are unsaved changes
   * @throws On iOS/Android
   */
  fun webHasUnsavedChanges(callback: (Result<Boolean>) -> Unit)

  companion object {
    /** The codec used by PdfDocumentApi. */
    val codec: MessageCodec<Any?> by lazy {
      NutrientApiPigeonCodec()
    }
    /** Sets up an instance of `PdfDocumentApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: PdfDocumentApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getPageInfo$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            api.getPageInfo(pageIndexArg) { result: Result<PageInfo> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.exportPdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val optionsArg = args[0] as DocumentSaveOptions?
            api.exportPdf(optionsArg) { result: Result<ByteArray> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getFormFieldJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val fieldNameArg = args[0] as String
            api.getFormFieldJson(fieldNameArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getFormFieldsJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getFormFieldsJson{ result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.setFormFieldValue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val valueArg = args[0] as String
            val fullyQualifiedNameArg = args[1] as String
            api.setFormFieldValue(valueArg, fullyQualifiedNameArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getFormFieldValue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val fullyQualifiedNameArg = args[0] as String
            api.getFormFieldValue(fullyQualifiedNameArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.applyInstantJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val annotationsJsonArg = args[0] as String
            api.applyInstantJson(annotationsJsonArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.exportInstantJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.exportInstantJson{ result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.addAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val jsonAnnotationArg = args[0] as String
            val attachmentArg = args[1]
            api.addAnnotation(jsonAnnotationArg, attachmentArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.updateAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val jsonAnnotationArg = args[0] as String
            api.updateAnnotation(jsonAnnotationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.removeAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val jsonAnnotationArg = args[0] as String
            api.removeAnnotation(jsonAnnotationArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getAnnotationsJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val typeArg = args[1] as String
            api.getAnnotationsJson(pageIndexArg, typeArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getAllUnsavedAnnotationsJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getAllUnsavedAnnotationsJson{ result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.importXfdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfStringArg = args[0] as String
            api.importXfdf(xfdfStringArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.exportXfdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfPathArg = args[0] as String
            api.exportXfdf(xfdfPathArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.save$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val outputPathArg = args[0] as String?
            val optionsArg = args[1] as DocumentSaveOptions?
            api.save(outputPathArg, optionsArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getPageCount$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getPageCount{ result: Result<Long> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.processAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val typeArg = args[0] as AnnotationType
            val processingModeArg = args[1] as AnnotationProcessingMode
            val destinationPathArg = args[2] as String
            api.processAnnotations(typeArg, processingModeArg, destinationPathArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.closeDocument$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.closeDocument{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.iOSHasDirtyAnnotations$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.iOSHasDirtyAnnotations{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.iOSGetAnnotationIsDirty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val annotationIdArg = args[1] as String
            api.iOSGetAnnotationIsDirty(pageIndexArg, annotationIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.iOSSetAnnotationIsDirty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val annotationIdArg = args[1] as String
            val isDirtyArg = args[2] as Boolean
            api.iOSSetAnnotationIsDirty(pageIndexArg, annotationIdArg, isDirtyArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.iOSClearNeedsSaveFlag$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.iOSClearNeedsSaveFlag{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.androidHasUnsavedAnnotationChanges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.androidHasUnsavedAnnotationChanges{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.androidHasUnsavedFormChanges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.androidHasUnsavedFormChanges{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.androidHasUnsavedBookmarkChanges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.androidHasUnsavedBookmarkChanges{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.androidGetBookmarkIsDirty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val bookmarkIdArg = args[0] as String
            api.androidGetBookmarkIsDirty(bookmarkIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.androidClearBookmarkDirtyState$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val bookmarkIdArg = args[0] as String
            api.androidClearBookmarkDirtyState(bookmarkIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.androidGetFormFieldIsDirty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val fullyQualifiedNameArg = args[0] as String
            api.androidGetFormFieldIsDirty(fullyQualifiedNameArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.webHasUnsavedChanges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.webHasUnsavedChanges{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * API for opening and managing PDF documents without displaying a viewer.
 *
 * This API enables programmatic access to PDF documents for operations like:
 * - Reading and modifying annotations
 * - Processing annotations (flatten, embed, remove)
 * - Exporting/importing XFDF
 * - Form field manipulation
 *
 * Documents opened through this API must be explicitly closed using
 * [PdfDocumentApi.closeDocument] when no longer needed to free resources.
 *
 * **Usage Example**:
 * ```dart
 * final documentId = await HeadlessDocumentApi.openDocument('/path/to/doc.pdf');
 * // Use PdfDocumentApi with the documentId for operations
 * final annotations = await pdfDocumentApi.getAnnotations(0, 'all');
 * await pdfDocumentApi.processAnnotations(
 *   AnnotationType.all,
 *   AnnotationProcessingMode.flatten,
 *   '/path/to/output.pdf',
 * );
 * await pdfDocumentApi.closeDocument();
 * ```
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface HeadlessDocumentApi {
  /**
   * Opens a document from the given path without displaying a viewer.
   *
   * Returns a unique document ID that can be used to interact with the
   * document via [PdfDocumentApi]. The document ID is used as a channel
   * suffix to create isolated API instances for each document.
   *
   * @param documentPath Path to the PDF document (file path or content:// URI)
   * @param options Optional settings like password for encrypted documents
   * @return Unique document ID for use with PdfDocumentApi
   * @throws NutrientApiError if the document cannot be opened
   */
  fun openDocument(documentPath: String, options: HeadlessDocumentOpenOptions?, callback: (Result<String>) -> Unit)

  companion object {
    /** The codec used by HeadlessDocumentApi. */
    val codec: MessageCodec<Any?> by lazy {
      NutrientApiPigeonCodec()
    }
    /** Sets up an instance of `HeadlessDocumentApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: HeadlessDocumentApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.HeadlessDocumentApi.openDocument$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val documentPathArg = args[0] as String
            val optionsArg = args[1] as HeadlessDocumentOpenOptions?
            api.openDocument(documentPathArg, optionsArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class NutrientViewCallbacks(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by NutrientViewCallbacks. */
    val codec: MessageCodec<Any?> by lazy {
      NutrientApiPigeonCodec()
    }
  }
  fun onDocumentLoaded(documentIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentLoaded$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onDocumentError(documentIdArg: String, errorArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onPageChanged(documentIdArg: String, pageIndexArg: Long, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onPageChanged$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, pageIndexArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onPageClick(documentIdArg: String, pageIndexArg: Long, pointArg: PointF?, annotationArg: Any?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onPageClick$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, pageIndexArg, pointArg, annotationArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onDocumentSaved(documentIdArg: String, pathArg: String?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentSaved$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(documentIdArg, pathArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class NutrientEventsCallbacks(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by NutrientEventsCallbacks. */
    val codec: MessageCodec<Any?> by lazy {
      NutrientApiPigeonCodec()
    }
  }
  fun onEvent(eventArg: NutrientEvent, dataArg: Any?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.NutrientEventsCallbacks.onEvent$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(eventArg, dataArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class AnalyticsEventsCallback(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by AnalyticsEventsCallback. */
    val codec: MessageCodec<Any?> by lazy {
      NutrientApiPigeonCodec()
    }
  }
  fun onEvent(eventArg: String, attributesArg: Map<String, Any?>?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.AnalyticsEventsCallback.onEvent$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(eventArg, attributesArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/**
 * Callbacks for custom toolbar item interactions
 *
 * Generated class from Pigeon that represents Flutter messages that can be called from Kotlin.
 */
class CustomToolbarCallbacks(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by CustomToolbarCallbacks. */
    val codec: MessageCodec<Any?> by lazy {
      NutrientApiPigeonCodec()
    }
  }
  /** Called when a custom toolbar item is tapped */
  fun onCustomToolbarItemTapped(identifierArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.nutrient_flutter.CustomToolbarCallbacks.onCustomToolbarItemTapped$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(identifierArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(NutrientApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/**
 * Manages annotations for a PDF document with proper data preservation.
 *
 * This API replaces the deprecated annotation methods in PdfDocumentApi
 * and provides a safe way to update annotations without losing attachments
 * or custom data.
 *
 * **Channel Management**: Each document instance creates its own AnnotationManager
 * with a unique channel ID prefixed by the document ID (e.g., "doc123_annotation_manager").
 * This allows multiple documents to have independent annotation managers.
 *
 * **Key Features**:
 * - Preserves attachments when updating annotation properties
 * - Maintains custom data during updates
 * - Only updates properties that are explicitly set (non-null)
 * - Provides batch update capabilities
 * - Supports search and filtering operations
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface AnnotationManagerApi {
  /**
   * Initialize the annotation manager for a specific document.
   * This should be called once when creating the manager instance.
   *
   * @param documentId The unique identifier of the document
   */
  fun initialize(documentId: String)
  /**
   * Get the current properties of an annotation.
   * Returns null if the annotation doesn't exist.
   *
   * @param pageIndex Zero-based page index
   * @param annotationId Unique identifier of the annotation
   * @return Current annotation properties or null if not found
   */
  fun getAnnotationProperties(pageIndex: Long, annotationId: String, callback: (Result<AnnotationProperties?>) -> Unit)
  /**
   * Save modified annotation properties.
   * Only non-null properties in modifiedProperties will be updated.
   * All other properties (including attachments and custom data) are preserved.
   *
   * @param modifiedProperties Properties to update (only non-null values are applied)
   * @return true if successfully saved, false otherwise
   */
  fun saveAnnotationProperties(modifiedProperties: AnnotationProperties, callback: (Result<Boolean>) -> Unit)
  /**
   * Get all annotations on a specific page.
   *
   * @param pageIndex Zero-based page index
   * @param annotationType Type of annotations to retrieve (e.g., "all", "ink", "note")
   * @return JSON string containing array of annotations
   * Using JSON string avoids Pigeon's CastList issues with nested types in release mode.
   */
  fun getAnnotationsJson(pageIndex: Long, annotationType: String, callback: (Result<String>) -> Unit)
  /**
   * Add a new annotation to the document.
   *
   * @param jsonAnnotation JSON representation of the annotation
   * @param jsonAttachment Optional JSON representation of attachment (for file/image annotations)
   * @return Unique identifier of the created annotation
   */
  fun addAnnotation(jsonAnnotation: String, jsonAttachment: String?, callback: (Result<String>) -> Unit)
  /**
   * Remove an annotation from the document.
   *
   * @param pageIndex Zero-based page index
   * @param annotationId Unique identifier of the annotation
   * @return true if successfully removed, false otherwise
   */
  fun removeAnnotation(pageIndex: Long, annotationId: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Search for annotations containing specific text.
   *
   * @param query Search term
   * @param pageIndex Optional page index to limit search scope
   * @return JSON string containing array of matching annotations
   * Using JSON string avoids Pigeon's CastList issues with nested types in release mode.
   */
  fun searchAnnotationsJson(query: String, pageIndex: Long?, callback: (Result<String>) -> Unit)
  /**
   * Export annotations as XFDF format.
   *
   * @param pageIndex Optional page index to export specific page annotations
   * @return XFDF string representation
   */
  fun exportXFDF(pageIndex: Long?, callback: (Result<String>) -> Unit)
  /**
   * Import annotations from XFDF format.
   *
   * @param xfdfString XFDF string to import
   * @return true if successfully imported, false otherwise
   */
  fun importXFDF(xfdfString: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Get all annotations that have unsaved changes.
   *
   * @return JSON string containing array of annotations with pending changes
   * Using JSON string avoids Pigeon's CastList issues with nested types in release mode.
   */
  fun getUnsavedAnnotationsJson(callback: (Result<String>) -> Unit)

  companion object {
    /** The codec used by AnnotationManagerApi. */
    val codec: MessageCodec<Any?> by lazy {
      NutrientApiPigeonCodec()
    }
    /** Sets up an instance of `AnnotationManagerApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: AnnotationManagerApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.initialize$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val documentIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.initialize(documentIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.getAnnotationProperties$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val annotationIdArg = args[1] as String
            api.getAnnotationProperties(pageIndexArg, annotationIdArg) { result: Result<AnnotationProperties?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.saveAnnotationProperties$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modifiedPropertiesArg = args[0] as AnnotationProperties
            api.saveAnnotationProperties(modifiedPropertiesArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.getAnnotationsJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val annotationTypeArg = args[1] as String
            api.getAnnotationsJson(pageIndexArg, annotationTypeArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.addAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val jsonAnnotationArg = args[0] as String
            val jsonAttachmentArg = args[1] as String?
            api.addAnnotation(jsonAnnotationArg, jsonAttachmentArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.removeAnnotation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            val annotationIdArg = args[1] as String
            api.removeAnnotation(pageIndexArg, annotationIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.searchAnnotationsJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val queryArg = args[0] as String
            val pageIndexArg = args[1] as Long?
            api.searchAnnotationsJson(queryArg, pageIndexArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.exportXFDF$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long?
            api.exportXFDF(pageIndexArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.importXFDF$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val xfdfStringArg = args[0] as String
            api.importXFDF(xfdfStringArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.getUnsavedAnnotationsJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getUnsavedAnnotationsJson{ result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * API for managing bookmarks in a PDF document.
 *
 * This API provides methods to add, remove, update, and retrieve bookmarks.
 * Bookmarks are user-created navigation markers that persist with the document.
 *
 * Bookmarks follow the Instant JSON specification format.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface BookmarkManagerApi {
  /**
   * Initialize the bookmark manager for a specific document.
   * This should be called once when creating the manager instance.
   *
   * @param documentId The unique identifier of the document
   */
  fun initialize(documentId: String)
  /**
   * Get all bookmarks in the document.
   *
   * @return List of all bookmarks
   */
  fun getBookmarks(callback: (Result<List<Bookmark>>) -> Unit)
  /**
   * Add a new bookmark to the document.
   *
   * @param bookmark The bookmark to add
   * @return The created bookmark with its assigned pdfBookmarkId
   */
  fun addBookmark(bookmark: Bookmark, callback: (Result<Bookmark>) -> Unit)
  /**
   * Remove a bookmark from the document.
   *
   * @param bookmark The bookmark to remove (identified by pdfBookmarkId or action)
   * @return true if successfully removed, false otherwise
   */
  fun removeBookmark(bookmark: Bookmark, callback: (Result<Boolean>) -> Unit)
  /**
   * Update an existing bookmark.
   *
   * @param bookmark The bookmark with updated values (must have a valid pdfBookmarkId)
   * @return true if successfully updated, false otherwise
   */
  fun updateBookmark(bookmark: Bookmark, callback: (Result<Boolean>) -> Unit)
  /**
   * Get bookmarks for a specific page.
   *
   * @param pageIndex Zero-based page index
   * @return List of bookmarks pointing to the specified page
   */
  fun getBookmarksForPage(pageIndex: Long, callback: (Result<List<Bookmark>>) -> Unit)
  /**
   * Check if a bookmark exists for a specific page.
   *
   * @param pageIndex Zero-based page index
   * @return true if at least one bookmark exists for the page
   */
  fun hasBookmarkForPage(pageIndex: Long, callback: (Result<Boolean>) -> Unit)

  companion object {
    /** The codec used by BookmarkManagerApi. */
    val codec: MessageCodec<Any?> by lazy {
      NutrientApiPigeonCodec()
    }
    /** Sets up an instance of `BookmarkManagerApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: BookmarkManagerApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.BookmarkManagerApi.initialize$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val documentIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.initialize(documentIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.BookmarkManagerApi.getBookmarks$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getBookmarks{ result: Result<List<Bookmark>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.BookmarkManagerApi.addBookmark$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val bookmarkArg = args[0] as Bookmark
            api.addBookmark(bookmarkArg) { result: Result<Bookmark> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.BookmarkManagerApi.removeBookmark$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val bookmarkArg = args[0] as Bookmark
            api.removeBookmark(bookmarkArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.BookmarkManagerApi.updateBookmark$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val bookmarkArg = args[0] as Bookmark
            api.updateBookmark(bookmarkArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.BookmarkManagerApi.getBookmarksForPage$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            api.getBookmarksForPage(pageIndexArg) { result: Result<List<Bookmark>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.nutrient_flutter.BookmarkManagerApi.hasBookmarkForPage$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pageIndexArg = args[0] as Long
            api.hasBookmarkForPage(pageIndexArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
