// Copyright Â© 2024-2025 PSPDFKit GmbH. All rights reserved.
//
// THIS SOURCE CODE AND ANY ACCOMPANYING DOCUMENTATION ARE PROTECTED BY INTERNATIONAL COPYRIGHT LAW
// AND MAY NOT BE RESOLD OR REDISTRIBUTED. USAGE IS BOUND TO THE PSPDFKIT LICENSE AGREEMENT.
// UNAUTHORIZED REPRODUCTION OR DISTRIBUTION IS SUBJECT TO CIVIL AND CRIMINAL PENALTIES.
// This notice may not be removed from this file.
// Autogenerated from Pigeon (v24.2.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

List<Object?> wrapResponse(
    {Object? result, PlatformException? error, bool empty = false}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}

enum AndroidPermissionStatus {
  notDetermined,
  denied,
  authorized,
  deniedNeverAsk,
}

/// Represents the native annotation type.
enum AnnotationType {
  all,
  none,
  undefined,
  link,
  highlight,
  strikeout,
  underline,
  squiggly,
  freeText,
  ink,
  square,
  circle,
  line,
  note,
  stamp,
  caret,
  media,
  screen,
  widget,
  file,
  sound,
  polygon,
  polyline,
  popup,
  watermark,
  trapNet,
  type3d,
  redact,
  image,
}

enum AnnotationTool {
  inkPen,
  inkMagic,
  inkHighlighter,
  freeText,
  freeTextCallOut,
  stamp,
  image,
  highlight,
  underline,
  squiggly,
  strikeOut,
  line,
  arrow,
  square,
  circle,
  polygon,
  polyline,
  eraser,
  cloudy,
  link,
  caret,
  richMedia,
  screen,
  file,
  widget,
  redaction,
  signature,
  stampImage,
  note,
  sound,
  measurementAreaRect,
  measurementAreaPolygon,
  measurementAreaEllipse,
  measurementPerimeter,
  measurementDistance,
}

enum AnnotationToolVariant {
  inkPen,
  inkMagic,
  inkHighlighter,
  freeText,
  freeTextCallOut,
  stamp,
  image,
  highlight,
  underline,
}

enum AnnotationProcessingMode {
  flatten,
  remove,
  embed,
  print,
}

enum DocumentPermissions {
  /// Allow printing of document.
  printing,

  /// Modify the contents of the document.
  modification,

  /// Copy text and images from the document.
  extract,

  /// Add or modify text annotations, fill in interactive form fields.
  annotationsAndForms,

  /// Fill in existing interactive form fields (including signature fields).
  fillForms,

  /// Extract text and images from the document.
  extractAccessibility,

  /// Assemble the document (insert, rotate, or delete pages and create document outline items or thumbnail images).
  assemble,

  /// Print high quality.
  printHighQuality,
}

/// The PDF version of a document.
enum PdfVersion {
  pdf_1_0,
  pdf_1_1,
  pdf_1_2,
  pdf_1_3,
  pdf_1_4,
  pdf_1_5,
  pdf_1_6,
  pdf_1_7,
}

enum PdfFormFieldTypes {
  text,
  checkbox,
  radioButton,
  comboBox,
  listBox,
  signature,
  button,
  unknown,
}

enum NutrientEvent {
  /// Event triggered when annotations are created.
  annotationsCreated,

  /// Event triggered when annotations are pressed.
  annotationsDeselected,

  /// Event triggered when annotations are updated.
  annotationsUpdated,

  /// Event triggered when annotations are deleted.
  annotationsDeleted,

  /// Event triggered when annotations are focused.
  annotationsSelected,

  /// Event triggered when form field values are updated.
  formFieldValuesUpdated,

  /// Event triggered when form fields are loaded.
  formFieldSelected,

  /// Event triggered when form fields are about to be saved.
  formFieldDeselected,

  /// Event triggered when text selection changes.
  textSelectionChanged,
}

/// Enumeration of default annotation menu actions that can be removed or disabled.
///
/// **Platform Support:**
/// - All actions can be removed or disabled on both iOS and Android
/// - Some system actions (copy/paste) may be harder to remove on iOS due to system restrictions
enum AnnotationMenuAction {
  /// Delete action - removes the annotation
  /// - iOS: Part of UIMenu system actions
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_delete
  delete,

  /// Copy action - copies the annotation
  /// - iOS: System copy action (may be harder to remove)
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_copy
  copy,

  /// Cut action - cuts the annotation to clipboard
  /// - iOS: System cut action
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_cut
  cut,

  /// Color action - opens annotation color picker/inspector
  /// - iOS: Style picker in UIMenu
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_picker
  color,

  /// Note action - opens annotation note editor
  /// - iOS: Note action in UIMenu
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_annotation_note
  note,

  /// Undo action - undoes the last action
  /// - iOS: Undo in UIMenu
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_undo
  undo,

  /// Redo action - redoes the previously undone action
  /// - iOS: Redo in UIMenu
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_redo
  redo,
}

class PdfRect {
  PdfRect({
    required this.x,
    required this.y,
    required this.width,
    required this.height,
  });

  double x;

  double y;

  double width;

  double height;

  Object encode() {
    return <Object?>[
      x,
      y,
      width,
      height,
    ];
  }

  static PdfRect decode(Object result) {
    result as List<Object?>;
    return PdfRect(
      x: result[0]! as double,
      y: result[1]! as double,
      width: result[2]! as double,
      height: result[3]! as double,
    );
  }
}

class PageInfo {
  PageInfo({
    required this.pageIndex,
    required this.height,
    required this.width,
    required this.rotation,
    this.label = '',
  });

  /// The index of the page. This is a zero-based index.
  int pageIndex;

  /// The height of the page in points.
  double height;

  /// The width of the page in points.
  double width;

  /// The rotation of the page in degrees.
  int rotation;

  /// The label of the page.
  String label;

  Object encode() {
    return <Object?>[
      pageIndex,
      height,
      width,
      rotation,
      label,
    ];
  }

  static PageInfo decode(Object result) {
    result as List<Object?>;
    return PageInfo(
      pageIndex: result[0]! as int,
      height: result[1]! as double,
      width: result[2]! as double,
      rotation: result[3]! as int,
      label: result[4]! as String,
    );
  }
}

class DocumentSaveOptions {
  DocumentSaveOptions({
    this.userPassword,
    this.ownerPassword,
    this.flatten,
    this.incremental,
    this.permissions,
    this.pdfVersion,
    this.excludeAnnotations,
    this.saveForPrinting,
    this.includeComments,
    this.outputFormat,
    this.optimize,
  });

  /// The password is used to encrypt the document. On Web, it's used as the user password.
  String? userPassword;

  /// The owner password is used to encrypt the document and set permissions. It's only used on Web.
  String? ownerPassword;

  /// Flatten annotations and form fields into the page content.
  bool? flatten;

  /// Whether to save the document incrementally.
  bool? incremental;

  /// The permissions to set on the document. See [DocumentPermissions] for more information.
  List<DocumentPermissions?>? permissions;

  /// The PDF version to save the document as.
  PdfVersion? pdfVersion;

  /// Whether to exclude annotations from the exported document.
  bool? excludeAnnotations;

  /// Whether to exclude annotations that have the noPrint flag set to true from the exported document (Standalone only)
  bool? saveForPrinting;

  /// Whether to include comments in the exported document (Server-Backed only).
  bool? includeComments;

  /// Whether tp allow you to export a PDF in PDF/A format.
  Object? outputFormat;

  /// Whether to optimize the document for the web.
  bool? optimize;

  Object encode() {
    return <Object?>[
      userPassword,
      ownerPassword,
      flatten,
      incremental,
      permissions,
      pdfVersion,
      excludeAnnotations,
      saveForPrinting,
      includeComments,
      outputFormat,
      optimize,
    ];
  }

  static DocumentSaveOptions decode(Object result) {
    result as List<Object?>;
    return DocumentSaveOptions(
      userPassword: result[0] as String?,
      ownerPassword: result[1] as String?,
      flatten: result[2] as bool?,
      incremental: result[3] as bool?,
      permissions: (result[4] as List<Object?>?)?.cast<DocumentPermissions?>(),
      pdfVersion: result[5] as PdfVersion?,
      excludeAnnotations: result[6] as bool?,
      saveForPrinting: result[7] as bool?,
      includeComments: result[8] as bool?,
      outputFormat: result[9],
      optimize: result[10] as bool?,
    );
  }
}

class PdfFormOption {
  PdfFormOption({
    required this.value,
    required this.label,
  });

  /// The value of the option.
  String value;

  /// The label of the option.
  String label;

  Object encode() {
    return <Object?>[
      value,
      label,
    ];
  }

  static PdfFormOption decode(Object result) {
    result as List<Object?>;
    return PdfFormOption(
      value: result[0]! as String,
      label: result[1]! as String,
    );
  }
}

class FormFieldData {
  FormFieldData({
    required this.name,
    this.alternativeFieldName,
    this.fullyQualifiedName,
    required this.type,
    this.annotations,
    this.isReadOnly,
    this.isRequired,
    this.isExported,
    this.isDirty,
    this.options,
  });

  String name;

  String? alternativeFieldName;

  String? fullyQualifiedName;

  PdfFormFieldTypes type;

  Object? annotations;

  bool? isReadOnly;

  bool? isRequired;

  bool? isExported;

  bool? isDirty;

  List<PdfFormOption?>? options;

  Object encode() {
    return <Object?>[
      name,
      alternativeFieldName,
      fullyQualifiedName,
      type,
      annotations,
      isReadOnly,
      isRequired,
      isExported,
      isDirty,
      options,
    ];
  }

  static FormFieldData decode(Object result) {
    result as List<Object?>;
    return FormFieldData(
      name: result[0]! as String,
      alternativeFieldName: result[1] as String?,
      fullyQualifiedName: result[2] as String?,
      type: result[3]! as PdfFormFieldTypes,
      annotations: result[4],
      isReadOnly: result[5] as bool?,
      isRequired: result[6] as bool?,
      isExported: result[7] as bool?,
      isDirty: result[8] as bool?,
      options: (result[9] as List<Object?>?)?.cast<PdfFormOption?>(),
    );
  }
}

class PointF {
  PointF({
    required this.x,
    required this.y,
  });

  double x;

  double y;

  Object encode() {
    return <Object?>[
      x,
      y,
    ];
  }

  static PointF decode(Object result) {
    result as List<Object?>;
    return PointF(
      x: result[0]! as double,
      y: result[1]! as double,
    );
  }
}

/// Configuration data for annotation contextual menu
///
/// This class defines how annotation menus should be configured
/// when displayed to users. It supports removing actions, disabling actions,
/// and controlling visual presentation options.
///
/// **Usage Patterns**:
/// - **Static Configuration**: Set once via [NutrientViewController.setAnnotationMenuConfiguration]
///
/// **Platform Compatibility**:
/// - [itemsToRemove]: Supported on Android, iOS, and Web
/// - [itemsToDisable]: Supported on Android, iOS, and Web
/// - [showStylePicker]: Supported on Android and iOS
/// - [groupMarkupItems]: iOS only (ignored on other platforms)
/// - [maxVisibleItems]: Platform-dependent behavior
class AnnotationMenuConfigurationData {
  AnnotationMenuConfigurationData({
    required this.itemsToRemove,
    required this.itemsToDisable,
    required this.showStylePicker,
    required this.groupMarkupItems,
    this.maxVisibleItems,
  });

  /// List of default annotation menu actions to remove completely from the menu.
  ///
  /// These actions will not appear in the contextual menu at all.
  /// Use this when you want to completely hide certain functionality.
  ///
  /// **Example**: Remove delete action for read-only annotations
  /// ```dart
  /// itemsToRemove: [AnnotationMenuAction.delete]
  /// ```
  List<AnnotationMenuAction> itemsToRemove;

  /// List of default annotation menu actions to disable (show as grayed out).
  ///
  /// These actions will appear in the menu but will be non-interactive.
  /// Use this when you want to show functionality exists but is temporarily unavailable.
  ///
  /// **Example**: Disable copy action for certain annotation types
  /// ```dart
  /// itemsToDisable: [AnnotationMenuAction.copy]
  /// ```
  List<AnnotationMenuAction> itemsToDisable;

  /// Whether to show the platform's default style picker in the annotation menu.
  ///
  /// When true, users can access color, thickness, and other style options
  /// directly from the annotation menu.
  ///
  /// **Platform Behavior**:
  /// - **iOS**: Shows style picker as part of UIMenu
  /// - **Android**: Shows annotation inspector/style picker
  /// - **Web**: Shows color picker and basic style options
  bool showStylePicker;

  /// Whether to group markup annotation actions together in the menu.
  ///
  /// When true, related markup actions (highlight, underline, etc.) are
  /// visually grouped in the menu for better organization.
  ///
  /// **Platform Support**: iOS only (ignored on Android and Web)
  bool groupMarkupItems;

  /// Maximum number of actions to show directly in the menu before creating overflow.
  ///
  /// When the number of available actions exceeds this limit, the platform
  /// may create a submenu or overflow menu to accommodate additional actions.
  ///
  /// **Platform Behavior**:
  /// - **iOS**: Respects platform UI guidelines for menu length
  /// - **Android**: Limited by toolbar space and screen size
  /// - **Web**: Creates scrollable or paginated menu as needed
  ///
  /// **Note**: If null, the platform default behavior is used.
  int? maxVisibleItems;

  Object encode() {
    return <Object?>[
      itemsToRemove,
      itemsToDisable,
      showStylePicker,
      groupMarkupItems,
      maxVisibleItems,
    ];
  }

  static AnnotationMenuConfigurationData decode(Object result) {
    result as List<Object?>;
    return AnnotationMenuConfigurationData(
      itemsToRemove:
          (result[0] as List<Object?>?)!.cast<AnnotationMenuAction>(),
      itemsToDisable:
          (result[1] as List<Object?>?)!.cast<AnnotationMenuAction>(),
      showStylePicker: result[2]! as bool,
      groupMarkupItems: result[3]! as bool,
      maxVisibleItems: result[4] as int?,
    );
  }
}

/// Data class for annotation properties that provides type-safe access
/// to annotation attributes while preserving attachments and custom data.
///
/// This class is used with the AnnotationManager API to safely update
/// annotation properties without losing data during the update process.
///
/// **Usage Pattern**:
/// ```dart
/// // Get current properties
/// final properties = await annotationManager.getAnnotationProperties(pageIndex, annotationId);
///
/// // Create modified version
/// final updated = properties?.withColor(Colors.red).withOpacity(0.7);
///
/// // Save changes
/// if (updated != null) {
///   await annotationManager.saveAnnotationProperties(updated);
/// }
/// ```
///
/// **Data Preservation**: Unlike the deprecated `updateAnnotation` method,
/// this approach preserves attachments, custom data, and other properties
/// that are not being explicitly modified.
class AnnotationProperties {
  AnnotationProperties({
    required this.annotationId,
    required this.pageIndex,
    this.strokeColor,
    this.fillColor,
    this.opacity,
    this.lineWidth,
    this.flags,
    this.customData,
    this.contents,
    this.subject,
    this.creator,
    this.bbox,
    this.note,
    this.inkLines,
    this.fontName,
    this.fontSize,
    this.iconName,
  });

  /// Unique identifier for the annotation
  String annotationId;

  /// Zero-based page index where the annotation is located
  int pageIndex;

  /// Stroke color as ARGB integer (e.g., 0xFFFF0000 for red)
  int? strokeColor;

  /// Fill color as ARGB integer (e.g., 0xFF0000FF for blue)
  int? fillColor;

  /// Opacity value between 0.0 (transparent) and 1.0 (opaque)
  double? opacity;

  /// Line width for stroke-based annotations (in points)
  double? lineWidth;

  /// List of annotation flags (e.g., ['readOnly', 'print'])
  List<String>? flags;

  /// Custom data associated with the annotation
  /// This preserves any application-specific metadata
  Map<String, Object?>? customData;

  /// Text content of the annotation (for text-based annotations)
  String? contents;

  /// Subject/title of the annotation
  String? subject;

  /// Creator/author of the annotation
  String? creator;

  /// Bounding box as [x, y, width, height] in PDF coordinates
  List<double>? bbox;

  /// Note text associated with the annotation
  String? note;

  /// Ink lines for ink annotations as [[[x, y, pressure], ...], ...]
  /// Each line is an array of points, each point is [x, y, pressure]
  List<List<List<double>>>? inkLines;

  /// Font name for text annotations
  String? fontName;

  /// Font size for text annotations (in points)
  double? fontSize;

  /// Icon name for note annotations (e.g., 'Comment', 'Key', 'Note')
  String? iconName;

  Object encode() {
    return <Object?>[
      annotationId,
      pageIndex,
      strokeColor,
      fillColor,
      opacity,
      lineWidth,
      flags,
      customData,
      contents,
      subject,
      creator,
      bbox,
      note,
      inkLines,
      fontName,
      fontSize,
      iconName,
    ];
  }

  static AnnotationProperties decode(Object result) {
    result as List<Object?>;
    return AnnotationProperties(
      annotationId: result[0]! as String,
      pageIndex: result[1]! as int,
      strokeColor: result[2] as int?,
      fillColor: result[3] as int?,
      opacity: result[4] as double?,
      lineWidth: result[5] as double?,
      flags: (result[6] as List<Object?>?)?.cast<String>(),
      customData:
          (result[7] as Map<Object?, Object?>?)?.cast<String, Object?>(),
      contents: result[8] as String?,
      subject: result[9] as String?,
      creator: result[10] as String?,
      bbox: (result[11] as List<Object?>?)?.cast<double>(),
      note: result[12] as String?,
      inkLines: (result[13] as List<Object?>?)?.cast<List<List<double>>>(),
      fontName: result[14] as String?,
      fontSize: result[15] as double?,
      iconName: result[16] as String?,
    );
  }
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is AndroidPermissionStatus) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    } else if (value is AnnotationType) {
      buffer.putUint8(130);
      writeValue(buffer, value.index);
    } else if (value is AnnotationTool) {
      buffer.putUint8(131);
      writeValue(buffer, value.index);
    } else if (value is AnnotationToolVariant) {
      buffer.putUint8(132);
      writeValue(buffer, value.index);
    } else if (value is AnnotationProcessingMode) {
      buffer.putUint8(133);
      writeValue(buffer, value.index);
    } else if (value is DocumentPermissions) {
      buffer.putUint8(134);
      writeValue(buffer, value.index);
    } else if (value is PdfVersion) {
      buffer.putUint8(135);
      writeValue(buffer, value.index);
    } else if (value is PdfFormFieldTypes) {
      buffer.putUint8(136);
      writeValue(buffer, value.index);
    } else if (value is NutrientEvent) {
      buffer.putUint8(137);
      writeValue(buffer, value.index);
    } else if (value is AnnotationMenuAction) {
      buffer.putUint8(138);
      writeValue(buffer, value.index);
    } else if (value is PdfRect) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else if (value is PageInfo) {
      buffer.putUint8(140);
      writeValue(buffer, value.encode());
    } else if (value is DocumentSaveOptions) {
      buffer.putUint8(141);
      writeValue(buffer, value.encode());
    } else if (value is PdfFormOption) {
      buffer.putUint8(142);
      writeValue(buffer, value.encode());
    } else if (value is FormFieldData) {
      buffer.putUint8(143);
      writeValue(buffer, value.encode());
    } else if (value is PointF) {
      buffer.putUint8(144);
      writeValue(buffer, value.encode());
    } else if (value is AnnotationMenuConfigurationData) {
      buffer.putUint8(145);
      writeValue(buffer, value.encode());
    } else if (value is AnnotationProperties) {
      buffer.putUint8(146);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : AndroidPermissionStatus.values[value];
      case 130:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : AnnotationType.values[value];
      case 131:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : AnnotationTool.values[value];
      case 132:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : AnnotationToolVariant.values[value];
      case 133:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : AnnotationProcessingMode.values[value];
      case 134:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : DocumentPermissions.values[value];
      case 135:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PdfVersion.values[value];
      case 136:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PdfFormFieldTypes.values[value];
      case 137:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : NutrientEvent.values[value];
      case 138:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : AnnotationMenuAction.values[value];
      case 139:
        return PdfRect.decode(readValue(buffer)!);
      case 140:
        return PageInfo.decode(readValue(buffer)!);
      case 141:
        return DocumentSaveOptions.decode(readValue(buffer)!);
      case 142:
        return PdfFormOption.decode(readValue(buffer)!);
      case 143:
        return FormFieldData.decode(readValue(buffer)!);
      case 144:
        return PointF.decode(readValue(buffer)!);
      case 145:
        return AnnotationMenuConfigurationData.decode(readValue(buffer)!);
      case 146:
        return AnnotationProperties.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// The API for interacting with a PDF document.
class NutrientApi {
  /// Constructor for [NutrientApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  NutrientApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<String?> getFrameworkVersion() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.getFrameworkVersion$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  Future<void> setLicenseKey(String? licenseKey) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.setLicenseKey$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[licenseKey]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setLicenseKeys(String? androidLicenseKey, String? iOSLicenseKey,
      String? webLicenseKey) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.setLicenseKeys$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel
        .send(<Object?>[androidLicenseKey, iOSLicenseKey, webLicenseKey]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool?> present(String document,
      {Map<String, Object>? configuration}) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.present$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[document, configuration]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<bool?> presentInstant(
    String serverUrl,
    String jwt, {
    Map<String, Object>? configuration,
  }) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.presentInstant$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[serverUrl, jwt, configuration]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<bool?> setFormFieldValue(
      String value, String fullyQualifiedName) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.setFormFieldValue$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[value, fullyQualifiedName]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<String?> getFormFieldValue(String fullyQualifiedName) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.getFormFieldValue$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[fullyQualifiedName]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  Future<bool?> applyInstantJson(String annotationsJson) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.applyInstantJson$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[annotationsJson]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<String?> exportInstantJson() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.exportInstantJson$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  Future<bool?> addAnnotation(String annotation, String? attachment) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.addAnnotation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[annotation, attachment]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<bool?> removeAnnotation(String annotation) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.removeAnnotation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[annotation]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<Object?> getAnnotations(int pageIndex, String type) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.getAnnotations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[pageIndex, type]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return pigeonVar_replyList[0];
    }
  }

  Future<Object?> getAllUnsavedAnnotations() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.getAllUnsavedAnnotations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return pigeonVar_replyList[0];
    }
  }

  Future<void> updateAnnotation(String annotation) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.updateAnnotation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[annotation]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool?> processAnnotations(AnnotationType type,
      AnnotationProcessingMode processingMode, String destinationPath) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.processAnnotations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel
        .send(<Object?>[type, processingMode, destinationPath]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<bool?> importXfdf(String xfdfString) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.importXfdf$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[xfdfString]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<bool?> exportXfdf(String xfdfPath) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.exportXfdf$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[xfdfPath]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<bool?> save() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.save$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<bool?> setDelayForSyncingLocalChanges(double delay) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.setDelayForSyncingLocalChanges$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[delay]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<bool?> setListenToServerChanges(bool listen) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.setListenToServerChanges$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[listen]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<bool?> syncAnnotations() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.syncAnnotations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<bool?> checkAndroidWriteExternalStoragePermission() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.checkAndroidWriteExternalStoragePermission$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<AndroidPermissionStatus>
      requestAndroidWriteExternalStoragePermission() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.requestAndroidWriteExternalStoragePermission$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as AndroidPermissionStatus?)!;
    }
  }

  Future<void> openAndroidSettings() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.openAndroidSettings$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool?> setAnnotationPresetConfigurations(
      Map<String, Object?> configurations) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.setAnnotationPresetConfigurations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[configurations]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<String> getTemporaryDirectory() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.getTemporaryDirectory$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  Future<void> setAuthorName(String name) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.setAuthorName$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[name]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String> getAuthorName() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.getAuthorName$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  /// Generate PDF from Images, Template, and Patterns.
  /// [pages]: [NewPage]s to be added to the PDF.
  /// [outputPath]: The path to the output file.
  /// Returns the path to the generated PDF path or null if the input is invalid or if the PDF generation fails.
  Future<String?> generatePdf(
      List<Map<String, Object>> pages, String outputPath) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.generatePdf$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[pages, outputPath]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  /// Generates a PDF from HTML string.
  ///
  /// [html]: The HTML string to be converted to PDF.
  /// [outPutFile]: The path to the output file.
  /// Returns the path to the generated PDF file or null if the input is invalid or if the PDF generation fails.
  Future<String?> generatePdfFromHtmlString(
      String html, String outPutFile, Map<String, Object>? options) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.generatePdfFromHtmlString$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[html, outPutFile, options]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  Future<String?> generatePdfFromHtmlUri(
      String htmlUri, String outPutFile, Map<String, Object>? options) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.generatePdfFromHtmlUri$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[htmlUri, outPutFile, options]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  /// Configure Nutrient Analytics events.
  Future<void> enableAnalyticsEvents(bool enable) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.enableAnalyticsEvents$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[enable]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Sets the annotation menu configuration for the global presenter.
  /// This configuration applies to all annotation menus in presented documents.
  ///
  /// @param configuration The annotation menu configuration to apply.
  /// @return True if the configuration was set successfully, false otherwise.
  Future<bool?> setAnnotationMenuConfiguration(
      AnnotationMenuConfigurationData configuration) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientApi.setAnnotationMenuConfiguration$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[configuration]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }
}

abstract class NutrientApiCallbacks {
  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  /// onPAuse callback for FlutterPdfActivity
  void onPdfActivityOnPause();

  void onPdfFragmentAdded();

  void onDocumentLoaded(String documentId);

  /// ViewControllerWillDismiss callback for PDFViewController
  void onPdfViewControllerWillDismiss();

  /// ViewControllerDidDismiss callback for PDFViewController
  void onPdfViewControllerDidDismiss();

  /// Called when instant synchronization starts.
  void onInstantSyncStarted(String documentId);

  /// Called when instant synchronization ends.
  void onInstantSyncFinished(String documentId);

  /// Called when instant synchronization fails.
  void onInstantSyncFailed(String documentId, String error);

  /// Called when instant authentication is done.
  void onInstantAuthenticationFinished(String documentId, String validJWT);

  /// Called when instant authentication fails.
  void onInstantAuthenticationFailed(String documentId, String error);

  /// Only available on iOS.
  /// Called when instant document download is done.
  void onInstantDownloadFinished(String documentId);

  /// Only available on iOS.
  /// Called when instant document download fails.
  void onInstantDownloadFailed(String documentId, String error);

  static void setUp(
    NutrientApiCallbacks? api, {
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) {
    messageChannelSuffix =
        messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onPdfActivityOnPause$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          try {
            api.onPdfActivityOnPause();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onPdfFragmentAdded$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          try {
            api.onPdfFragmentAdded();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onDocumentLoaded$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onDocumentLoaded was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onDocumentLoaded was null, expected non-null String.');
          try {
            api.onDocumentLoaded(arg_documentId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onPdfViewControllerWillDismiss$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          try {
            api.onPdfViewControllerWillDismiss();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onPdfViewControllerDidDismiss$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          try {
            api.onPdfViewControllerDidDismiss();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncStarted$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncStarted was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncStarted was null, expected non-null String.');
          try {
            api.onInstantSyncStarted(arg_documentId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncFinished$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncFinished was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncFinished was null, expected non-null String.');
          try {
            api.onInstantSyncFinished(arg_documentId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncFailed$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncFailed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncFailed was null, expected non-null String.');
          final String? arg_error = (args[1] as String?);
          assert(arg_error != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncFailed was null, expected non-null String.');
          try {
            api.onInstantSyncFailed(arg_documentId!, arg_error!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantAuthenticationFinished$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantAuthenticationFinished was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantAuthenticationFinished was null, expected non-null String.');
          final String? arg_validJWT = (args[1] as String?);
          assert(arg_validJWT != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantAuthenticationFinished was null, expected non-null String.');
          try {
            api.onInstantAuthenticationFinished(arg_documentId!, arg_validJWT!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantAuthenticationFailed$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantAuthenticationFailed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantAuthenticationFailed was null, expected non-null String.');
          final String? arg_error = (args[1] as String?);
          assert(arg_error != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantAuthenticationFailed was null, expected non-null String.');
          try {
            api.onInstantAuthenticationFailed(arg_documentId!, arg_error!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantDownloadFinished$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantDownloadFinished was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantDownloadFinished was null, expected non-null String.');
          try {
            api.onInstantDownloadFinished(arg_documentId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantDownloadFailed$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantDownloadFailed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantDownloadFailed was null, expected non-null String.');
          final String? arg_error = (args[1] as String?);
          assert(arg_error != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantDownloadFailed was null, expected non-null String.');
          try {
            api.onInstantDownloadFailed(arg_documentId!, arg_error!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}

class NutrientViewControllerApi {
  /// Constructor for [NutrientViewControllerApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  NutrientViewControllerApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Sets the value of a form field by specifying its fully qualified field name.
  /// This method is deprecated. Use [PdfDocument.setFormFieldValue] instead.
  Future<bool?> setFormFieldValue(
      String value, String fullyQualifiedName) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.setFormFieldValue$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[value, fullyQualifiedName]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  /// Gets the form field value by specifying its fully qualified name.
  Future<String?> getFormFieldValue(String fullyQualifiedName) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getFormFieldValue$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[fullyQualifiedName]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  /// Applies Instant document JSON to the presented document.
  Future<bool?> applyInstantJson(String annotationsJson) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.applyInstantJson$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[annotationsJson]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  /// Exports Instant document JSON from the presented document.
  Future<String?> exportInstantJson() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.exportInstantJson$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  /// Adds the given annotation to the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  Future<bool?> addAnnotation(String annotation) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.addAnnotation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[annotation]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  /// Removes the given annotation from the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  Future<bool?> removeAnnotation(String annotation) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.removeAnnotation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[annotation]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  /// Returns a list of JSON dictionaries for all the annotations of the given `type` on the given `pageIndex`.
  Future<Object> getAnnotations(int pageIndex, String type) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getAnnotations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[pageIndex, type]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return pigeonVar_replyList[0]!;
    }
  }

  /// Returns a list of JSON dictionaries for all the unsaved annotations in the presented document.
  Future<Object> getAllUnsavedAnnotations() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getAllUnsavedAnnotations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return pigeonVar_replyList[0]!;
    }
  }

  /// Processes annotations of the given type with the provided processing
  /// mode and stores the PDF at the given destination path.
  Future<bool> processAnnotations(AnnotationType type,
      AnnotationProcessingMode processingMode, String destinationPath) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.processAnnotations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel
        .send(<Object?>[type, processingMode, destinationPath]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Imports annotations from the XFDF file at the given path.
  Future<bool> importXfdf(String xfdfString) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.importXfdf$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[xfdfString]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Exports annotations to the XFDF file at the given path.
  Future<bool> exportXfdf(String xfdfPath) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.exportXfdf$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[xfdfPath]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Saves the document back to its original location if it has been changed.
  /// If there were no changes to the document, the document file will not be modified.
  Future<bool> save() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.save$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Sets the annotation preset configurations for the given annotation tools.
  /// @param configurations A map of annotation tools and their corresponding configurations.
  /// @param modifyAssociatedAnnotations Whether to modify the annotations associated with the old configuration. Only used for Android.
  /// @return True if the configurations were set successfully, false otherwise.
  Future<bool?> setAnnotationConfigurations(
      Map<String, Map<String, Object>> configurations) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.setAnnotationConfigurations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[configurations]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  /// Gets the visible rect of the given page.
  /// pageIndex The index of the page. This is a zero-based index.
  /// Returns a [Future] that completes with the visible rect of the given page.
  Future<PdfRect> getVisibleRect(int pageIndex) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getVisibleRect$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[pageIndex]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as PdfRect?)!;
    }
  }

  /// Zooms to the given rect on the given page.
  /// pageIndex The index of the page. This is a zero-based index.
  /// rect The rect to zoom to.
  /// Returns a [Future] that completes when the zoom operation is done.
  Future<bool> zoomToRect(
      int pageIndex, PdfRect rect, bool? animated, double? duration) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.zoomToRect$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[pageIndex, rect, animated, duration]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Gets the zoom scale of the given page.
  /// pageIndex The index of the page. This is a zero-based index.
  /// Returns a [Future] that completes with the zoom scale of the given page.
  Future<double> getZoomScale(int pageIndex) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getZoomScale$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[pageIndex]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as double?)!;
    }
  }

  Future<void> addEventListener(NutrientEvent event) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.addEventListener$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[event]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> removeEventListener(NutrientEvent event) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.removeEventListener$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[event]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Enters annotation creation mode.
  ///
  /// If [annotationTool] is provided, that specific tool will be activated.
  /// If no tool is provided, the default annotation tool will be used.
  ///
  /// Returns a [Future] that completes with a boolean indicating whether
  /// entering annotation creation mode was successful.
  Future<bool?> enterAnnotationCreationMode(
      AnnotationTool? annotationTool) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.enterAnnotationCreationMode$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[annotationTool]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  /// Exits annotation creation mode.
  ///
  /// Returns a [Future] that completes with a boolean indicating whether
  /// exiting annotation creation mode was successful.
  Future<bool?> exitAnnotationCreationMode() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.exitAnnotationCreationMode$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  /// Sets the annotation menu configuration for the current view controller.
  /// This configuration applies only to annotation menus in the current document view.
  ///
  /// @param configuration The annotation menu configuration to apply.
  /// @return True if the configuration was set successfully, false otherwise.
  Future<bool?> setAnnotationMenuConfiguration(
      AnnotationMenuConfigurationData configuration) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.setAnnotationMenuConfiguration$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[configuration]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }
}

class PdfDocumentApi {
  /// Constructor for [PdfDocumentApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PdfDocumentApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Returns the page info for the given page index.
  /// pageIndex The index of the page. This is a zero-based index.
  Future<PageInfo> getPageInfo(int pageIndex) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getPageInfo$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[pageIndex]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as PageInfo?)!;
    }
  }

  /// Exports the document as a PDF.
  /// options:[DocumentSaveOptions] The options to use when exporting the document.
  /// Returns a [Uint8List] containing the exported PDF data.
  Future<Uint8List> exportPdf(DocumentSaveOptions? options) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.exportPdf$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[options]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as Uint8List?)!;
    }
  }

  Future<Map<String, Object?>> getFormField(String fieldName) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getFormField$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[fieldName]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String, Object?>();
    }
  }

  /// Returns a list of all form fields in the document.
  Future<List<Map<String, Object?>>> getFormFields() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getFormFields$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<Map<String, Object?>>();
    }
  }

  /// Sets the value of a form field by specifying its fully qualified field name.
  Future<bool?> setFormFieldValue(
      String value, String fullyQualifiedName) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.setFormFieldValue$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[value, fullyQualifiedName]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  /// Gets the form field value by specifying its fully qualified name.
  Future<String?> getFormFieldValue(String fullyQualifiedName) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getFormFieldValue$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[fullyQualifiedName]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  /// Applies Instant document JSON to the presented document.
  Future<bool?> applyInstantJson(String annotationsJson) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.applyInstantJson$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[annotationsJson]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  /// Exports Instant document JSON from the presented document.
  Future<String?> exportInstantJson() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.exportInstantJson$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  /// Adds the given annotation to the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  Future<bool?> addAnnotation(String jsonAnnotation, Object? attachment) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.addAnnotation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[jsonAnnotation, attachment]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  /// Updates the given annotation in the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  ///
  /// @deprecated Use setAnnotationProperties() or specific property setters instead.
  /// This method has a critical bug that causes data loss for annotations with attachments.
  /// It will be removed in version 7.0.0.
  ///
  /// Migration:
  /// - For single property updates: Use specific setters like setAnnotationColor()
  /// - For multiple property updates: Use setAnnotationProperties()
  Future<bool?> updateAnnotation(String jsonAnnotation) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.updateAnnotation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[jsonAnnotation]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  /// Removes the given annotation from the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  Future<bool?> removeAnnotation(String jsonAnnotation) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.removeAnnotation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[jsonAnnotation]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  /// Returns a list of JSON dictionaries for all the annotations of the given `type` on the given `pageIndex`.
  Future<Object> getAnnotations(int pageIndex, String type) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getAnnotations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[pageIndex, type]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return pigeonVar_replyList[0]!;
    }
  }

  /// Returns a list of JSON dictionaries for all the unsaved annotations in the presented document.
  Future<Object> getAllUnsavedAnnotations() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getAllUnsavedAnnotations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return pigeonVar_replyList[0]!;
    }
  }

  /// Imports annotations from the XFDF file at the given path.
  Future<bool> importXfdf(String xfdfString) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.importXfdf$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[xfdfString]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Exports annotations to the XFDF file at the given path.
  Future<bool> exportXfdf(String xfdfPath) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.exportXfdf$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[xfdfPath]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Saves the document back to its original location if it has been changed.
  /// If there were no changes to the document, the document file will not be modified.
  Future<bool> save(String? outputPath, DocumentSaveOptions? options) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.save$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[outputPath, options]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Get the total number of pages in the document.
  Future<int> getPageCount() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getPageCount$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as int?)!;
    }
  }
}

abstract class NutrientViewCallbacks {
  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  void onDocumentLoaded(String documentId);

  void onDocumentError(String documentId, String error);

  void onPageChanged(String documentId, int pageIndex);

  void onPageClick(
      String documentId, int pageIndex, PointF? point, Object? annotation);

  void onDocumentSaved(String documentId, String? path);

  static void setUp(
    NutrientViewCallbacks? api, {
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) {
    messageChannelSuffix =
        messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentLoaded$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentLoaded was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentLoaded was null, expected non-null String.');
          try {
            api.onDocumentLoaded(arg_documentId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentError$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentError was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentError was null, expected non-null String.');
          final String? arg_error = (args[1] as String?);
          assert(arg_error != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentError was null, expected non-null String.');
          try {
            api.onDocumentError(arg_documentId!, arg_error!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onPageChanged$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onPageChanged was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onPageChanged was null, expected non-null String.');
          final int? arg_pageIndex = (args[1] as int?);
          assert(arg_pageIndex != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onPageChanged was null, expected non-null int.');
          try {
            api.onPageChanged(arg_documentId!, arg_pageIndex!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onPageClick$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onPageClick was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onPageClick was null, expected non-null String.');
          final int? arg_pageIndex = (args[1] as int?);
          assert(arg_pageIndex != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onPageClick was null, expected non-null int.');
          final PointF? arg_point = (args[2] as PointF?);
          final Object? arg_annotation = (args[3] as Object?);
          try {
            api.onPageClick(
                arg_documentId!, arg_pageIndex!, arg_point, arg_annotation);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentSaved$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentSaved was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_documentId = (args[0] as String?);
          assert(arg_documentId != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentSaved was null, expected non-null String.');
          final String? arg_path = (args[1] as String?);
          try {
            api.onDocumentSaved(arg_documentId!, arg_path);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}

abstract class NutrientEventsCallbacks {
  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  void onEvent(NutrientEvent event, Object? data);

  static void setUp(
    NutrientEventsCallbacks? api, {
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) {
    messageChannelSuffix =
        messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.NutrientEventsCallbacks.onEvent$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientEventsCallbacks.onEvent was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final NutrientEvent? arg_event = (args[0] as NutrientEvent?);
          assert(arg_event != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.NutrientEventsCallbacks.onEvent was null, expected non-null NutrientEvent.');
          final Object? arg_data = (args[1] as Object?);
          try {
            api.onEvent(arg_event!, arg_data);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}

abstract class AnalyticsEventsCallback {
  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  void onEvent(String event, Map<String, Object?>? attributes);

  static void setUp(
    AnalyticsEventsCallback? api, {
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) {
    messageChannelSuffix =
        messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.AnalyticsEventsCallback.onEvent$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.AnalyticsEventsCallback.onEvent was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_event = (args[0] as String?);
          assert(arg_event != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.AnalyticsEventsCallback.onEvent was null, expected non-null String.');
          final Map<String, Object?>? arg_attributes =
              (args[1] as Map<Object?, Object?>?)?.cast<String, Object?>();
          try {
            api.onEvent(arg_event!, arg_attributes);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}

/// Callbacks for custom toolbar item interactions
abstract class CustomToolbarCallbacks {
  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  /// Called when a custom toolbar item is tapped
  void onCustomToolbarItemTapped(String identifier);

  static void setUp(
    CustomToolbarCallbacks? api, {
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) {
    messageChannelSuffix =
        messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.nutrient_flutter.CustomToolbarCallbacks.onCustomToolbarItemTapped$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.CustomToolbarCallbacks.onCustomToolbarItemTapped was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_identifier = (args[0] as String?);
          assert(arg_identifier != null,
              'Argument for dev.flutter.pigeon.nutrient_flutter.CustomToolbarCallbacks.onCustomToolbarItemTapped was null, expected non-null String.');
          try {
            api.onCustomToolbarItemTapped(arg_identifier!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}

/// Manages annotations for a PDF document with proper data preservation.
///
/// This API replaces the deprecated annotation methods in PdfDocumentApi
/// and provides a safe way to update annotations without losing attachments
/// or custom data.
///
/// **Channel Management**: Each document instance creates its own AnnotationManager
/// with a unique channel ID prefixed by the document ID (e.g., "doc123_annotation_manager").
/// This allows multiple documents to have independent annotation managers.
///
/// **Key Features**:
/// - Preserves attachments when updating annotation properties
/// - Maintains custom data during updates
/// - Only updates properties that are explicitly set (non-null)
/// - Provides batch update capabilities
/// - Supports search and filtering operations
class AnnotationManagerApi {
  /// Constructor for [AnnotationManagerApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  AnnotationManagerApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Initialize the annotation manager for a specific document.
  /// This should be called once when creating the manager instance.
  ///
  /// @param documentId The unique identifier of the document
  Future<void> initialize(String documentId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.initialize$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[documentId]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Get the current properties of an annotation.
  /// Returns null if the annotation doesn't exist.
  ///
  /// @param pageIndex Zero-based page index
  /// @param annotationId Unique identifier of the annotation
  /// @return Current annotation properties or null if not found
  Future<AnnotationProperties?> getAnnotationProperties(
      int pageIndex, String annotationId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.getAnnotationProperties$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[pageIndex, annotationId]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as AnnotationProperties?);
    }
  }

  /// Save modified annotation properties.
  /// Only non-null properties in modifiedProperties will be updated.
  /// All other properties (including attachments and custom data) are preserved.
  ///
  /// @param modifiedProperties Properties to update (only non-null values are applied)
  /// @return true if successfully saved, false otherwise
  Future<bool> saveAnnotationProperties(
      AnnotationProperties modifiedProperties) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.saveAnnotationProperties$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[modifiedProperties]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Get all annotations on a specific page.
  ///
  /// @param pageIndex Zero-based page index
  /// @param annotationType Type of annotations to retrieve (e.g., "all", "ink", "note")
  /// @return List of annotations as JSON-compatible maps
  Future<Object> getAnnotations(int pageIndex, String annotationType) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.getAnnotations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[pageIndex, annotationType]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return pigeonVar_replyList[0]!;
    }
  }

  /// Add a new annotation to the document.
  ///
  /// @param jsonAnnotation JSON representation of the annotation
  /// @param jsonAttachment Optional JSON representation of attachment (for file/image annotations)
  /// @return Unique identifier of the created annotation
  Future<String> addAnnotation(
      String jsonAnnotation, String? jsonAttachment) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.addAnnotation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[jsonAnnotation, jsonAttachment]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  /// Remove an annotation from the document.
  ///
  /// @param pageIndex Zero-based page index
  /// @param annotationId Unique identifier of the annotation
  /// @return true if successfully removed, false otherwise
  Future<bool> removeAnnotation(int pageIndex, String annotationId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.removeAnnotation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[pageIndex, annotationId]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Search for annotations containing specific text.
  ///
  /// @param query Search term
  /// @param pageIndex Optional page index to limit search scope
  /// @return List of matching annotations
  Future<Object> searchAnnotations(String query, int? pageIndex) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.searchAnnotations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[query, pageIndex]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return pigeonVar_replyList[0]!;
    }
  }

  /// Export annotations as XFDF format.
  ///
  /// @param pageIndex Optional page index to export specific page annotations
  /// @return XFDF string representation
  Future<String> exportXFDF(int? pageIndex) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.exportXFDF$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[pageIndex]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  /// Import annotations from XFDF format.
  ///
  /// @param xfdfString XFDF string to import
  /// @return true if successfully imported, false otherwise
  Future<bool> importXFDF(String xfdfString) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.importXFDF$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture =
        pigeonVar_channel.send(<Object?>[xfdfString]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Get all annotations that have unsaved changes.
  ///
  /// @return List of annotations with pending changes
  Future<Object> getUnsavedAnnotations() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.getUnsavedAnnotations$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return pigeonVar_replyList[0]!;
    }
  }
}
