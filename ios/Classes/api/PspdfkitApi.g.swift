// Copyright Â© 2024-2025 PSPDFKit GmbH. All rights reserved.
//
// THIS SOURCE CODE AND ANY ACCOMPANYING DOCUMENTATION ARE PROTECTED BY INTERNATIONAL COPYRIGHT LAW
// AND MAY NOT BE RESOLD OR REDISTRIBUTED. USAGE IS BOUND TO THE PSPDFKIT LICENSE AGREEMENT.
// UNAUTHORIZED REPRODUCTION OR DISTRIBUTION IS SUBJECT TO CIVIL AND CRIMINAL PENALTIES.
// This notice may not be removed from this file.
// Autogenerated from Pigeon (v24.2.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PspdfkitApiError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PspdfkitApiError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PspdfkitApiError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PspdfkitApiError {
  return PspdfkitApiError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum AndroidPermissionStatus: Int {
  case notDetermined = 0
  case denied = 1
  case authorized = 2
  case deniedNeverAsk = 3
}

/// Represents the native annotation type.
enum AnnotationType: Int {
  case all = 0
  case none = 1
  case undefined = 2
  case link = 3
  case highlight = 4
  case strikeout = 5
  case underline = 6
  case squiggly = 7
  case freeText = 8
  case ink = 9
  case square = 10
  case circle = 11
  case line = 12
  case note = 13
  case stamp = 14
  case caret = 15
  case media = 16
  case screen = 17
  case widget = 18
  case file = 19
  case sound = 20
  case polygon = 21
  case polyline = 22
  case popup = 23
  case watermark = 24
  case trapNet = 25
  case type3d = 26
  case redact = 27
  case image = 28
}

enum AnnotationTool: Int {
  case inkPen = 0
  case inkMagic = 1
  case inkHighlighter = 2
  case freeText = 3
  case freeTextCallOut = 4
  case stamp = 5
  case image = 6
  case highlight = 7
  case underline = 8
  case squiggly = 9
  case strikeOut = 10
  case line = 11
  case arrow = 12
  case square = 13
  case circle = 14
  case polygon = 15
  case polyline = 16
  case eraser = 17
  case cloudy = 18
  case link = 19
  case caret = 20
  case richMedia = 21
  case screen = 22
  case file = 23
  case widget = 24
  case redaction = 25
  case signature = 26
  case stampImage = 27
  case note = 28
  case sound = 29
  case measurementAreaRect = 30
  case measurementAreaPolygon = 31
  case measurementAreaEllipse = 32
  case measurementPerimeter = 33
  case measurementDistance = 34
}

enum AnnotationToolVariant: Int {
  case inkPen = 0
  case inkMagic = 1
  case inkHighlighter = 2
  case freeText = 3
  case freeTextCallOut = 4
  case stamp = 5
  case image = 6
  case highlight = 7
  case underline = 8
}

enum AnnotationProcessingMode: Int {
  case flatten = 0
  case remove = 1
  case embed = 2
  case print = 3
}

enum DocumentPermissions: Int {
  /// Allow printing of document.
  case printing = 0
  /// Modify the contents of the document.
  case modification = 1
  /// Copy text and images from the document.
  case extract = 2
  /// Add or modify text annotations, fill in interactive form fields.
  case annotationsAndForms = 3
  /// Fill in existing interactive form fields (including signature fields).
  case fillForms = 4
  /// Extract text and images from the document.
  case extractAccessibility = 5
  /// Assemble the document (insert, rotate, or delete pages and create document outline items or thumbnail images).
  case assemble = 6
  /// Print high quality.
  case printHighQuality = 7
}

/// The PDF version of a document.
enum PdfVersion: Int {
  case pdf10 = 0
  case pdf11 = 1
  case pdf12 = 2
  case pdf13 = 3
  case pdf14 = 4
  case pdf15 = 5
  case pdf16 = 6
  case pdf17 = 7
}

enum PdfFormFieldTypes: Int {
  case text = 0
  case checkbox = 1
  case radioButton = 2
  case comboBox = 3
  case listBox = 4
  case signature = 5
  case button = 6
  case unknown = 7
}

enum NutrientEvent: Int {
  /// Event triggered when annotations are created.
  case annotationsCreated = 0
  /// Event triggered when annotations are pressed.
  case annotationsDeselected = 1
  /// Event triggered when annotations are updated.
  case annotationsUpdated = 2
  /// Event triggered when annotations are deleted.
  case annotationsDeleted = 3
  /// Event triggered when annotations are focused.
  case annotationsSelected = 4
  /// Event triggered when form field values are updated.
  case formFieldValuesUpdated = 5
  /// Event triggered when form fields are loaded.
  case formFieldSelected = 6
  /// Event triggered when form fields are about to be saved.
  case formFieldDeselected = 7
  /// Event triggered when text selection changes.
  case textSelectionChanged = 8
}

/// Generated class from Pigeon that represents data sent in messages.
struct PdfRect {
  var x: Double
  var y: Double
  var width: Double
  var height: Double


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PdfRect? {
    let x = pigeonVar_list[0] as! Double
    let y = pigeonVar_list[1] as! Double
    let width = pigeonVar_list[2] as! Double
    let height = pigeonVar_list[3] as! Double

    return PdfRect(
      x: x,
      y: y,
      width: width,
      height: height
    )
  }
  func toList() -> [Any?] {
    return [
      x,
      y,
      width,
      height,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PageInfo {
  /// The index of the page. This is a zero-based index.
  var pageIndex: Int64
  /// The height of the page in points.
  var height: Double
  /// The width of the page in points.
  var width: Double
  /// The rotation of the page in degrees.
  var rotation: Int64
  /// The label of the page.
  var label: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PageInfo? {
    let pageIndex = pigeonVar_list[0] as! Int64
    let height = pigeonVar_list[1] as! Double
    let width = pigeonVar_list[2] as! Double
    let rotation = pigeonVar_list[3] as! Int64
    let label = pigeonVar_list[4] as! String

    return PageInfo(
      pageIndex: pageIndex,
      height: height,
      width: width,
      rotation: rotation,
      label: label
    )
  }
  func toList() -> [Any?] {
    return [
      pageIndex,
      height,
      width,
      rotation,
      label,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct DocumentSaveOptions {
  /// The password is used to encrypt the document. On Web, it's used as the user password.
  var userPassword: String? = nil
  /// The owner password is used to encrypt the document and set permissions. It's only used on Web.
  var ownerPassword: String? = nil
  /// Flatten annotations and form fields into the page content.
  var flatten: Bool? = nil
  /// Whether to save the document incrementally.
  var incremental: Bool? = nil
  /// The permissions to set on the document. See [DocumentPermissions] for more information.
  var permissions: [DocumentPermissions?]? = nil
  /// The PDF version to save the document as.
  var pdfVersion: PdfVersion? = nil
  /// Whether to exclude annotations from the exported document.
  var excludeAnnotations: Bool? = nil
  /// Whether to exclude annotations that have the noPrint flag set to true from the exported document (Standalone only)
  var saveForPrinting: Bool? = nil
  /// Whether to include comments in the exported document (Server-Backed only).
  var includeComments: Bool? = nil
  /// Whether tp allow you to export a PDF in PDF/A format.
  var outputFormat: Any? = nil
  /// Whether to optimize the document for the web.
  var optimize: Bool? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DocumentSaveOptions? {
    let userPassword: String? = nilOrValue(pigeonVar_list[0])
    let ownerPassword: String? = nilOrValue(pigeonVar_list[1])
    let flatten: Bool? = nilOrValue(pigeonVar_list[2])
    let incremental: Bool? = nilOrValue(pigeonVar_list[3])
    let permissions: [DocumentPermissions?]? = nilOrValue(pigeonVar_list[4])
    let pdfVersion: PdfVersion? = nilOrValue(pigeonVar_list[5])
    let excludeAnnotations: Bool? = nilOrValue(pigeonVar_list[6])
    let saveForPrinting: Bool? = nilOrValue(pigeonVar_list[7])
    let includeComments: Bool? = nilOrValue(pigeonVar_list[8])
    let outputFormat: Any? = pigeonVar_list[9]
    let optimize: Bool? = nilOrValue(pigeonVar_list[10])

    return DocumentSaveOptions(
      userPassword: userPassword,
      ownerPassword: ownerPassword,
      flatten: flatten,
      incremental: incremental,
      permissions: permissions,
      pdfVersion: pdfVersion,
      excludeAnnotations: excludeAnnotations,
      saveForPrinting: saveForPrinting,
      includeComments: includeComments,
      outputFormat: outputFormat,
      optimize: optimize
    )
  }
  func toList() -> [Any?] {
    return [
      userPassword,
      ownerPassword,
      flatten,
      incremental,
      permissions,
      pdfVersion,
      excludeAnnotations,
      saveForPrinting,
      includeComments,
      outputFormat,
      optimize,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PdfFormOption {
  /// The value of the option.
  var value: String
  /// The label of the option.
  var label: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PdfFormOption? {
    let value = pigeonVar_list[0] as! String
    let label = pigeonVar_list[1] as! String

    return PdfFormOption(
      value: value,
      label: label
    )
  }
  func toList() -> [Any?] {
    return [
      value,
      label,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct FormFieldData {
  var name: String
  var alternativeFieldName: String? = nil
  var fullyQualifiedName: String? = nil
  var type: PdfFormFieldTypes
  var annotations: Any? = nil
  var isReadOnly: Bool? = nil
  var isRequired: Bool? = nil
  var isExported: Bool? = nil
  var isDirty: Bool? = nil
  var options: [PdfFormOption?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> FormFieldData? {
    let name = pigeonVar_list[0] as! String
    let alternativeFieldName: String? = nilOrValue(pigeonVar_list[1])
    let fullyQualifiedName: String? = nilOrValue(pigeonVar_list[2])
    let type = pigeonVar_list[3] as! PdfFormFieldTypes
    let annotations: Any? = pigeonVar_list[4]
    let isReadOnly: Bool? = nilOrValue(pigeonVar_list[5])
    let isRequired: Bool? = nilOrValue(pigeonVar_list[6])
    let isExported: Bool? = nilOrValue(pigeonVar_list[7])
    let isDirty: Bool? = nilOrValue(pigeonVar_list[8])
    let options: [PdfFormOption?]? = nilOrValue(pigeonVar_list[9])

    return FormFieldData(
      name: name,
      alternativeFieldName: alternativeFieldName,
      fullyQualifiedName: fullyQualifiedName,
      type: type,
      annotations: annotations,
      isReadOnly: isReadOnly,
      isRequired: isRequired,
      isExported: isExported,
      isDirty: isDirty,
      options: options
    )
  }
  func toList() -> [Any?] {
    return [
      name,
      alternativeFieldName,
      fullyQualifiedName,
      type,
      annotations,
      isReadOnly,
      isRequired,
      isExported,
      isDirty,
      options,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PointF {
  var x: Double
  var y: Double


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PointF? {
    let x = pigeonVar_list[0] as! Double
    let y = pigeonVar_list[1] as! Double

    return PointF(
      x: x,
      y: y
    )
  }
  func toList() -> [Any?] {
    return [
      x,
      y,
    ]
  }
}

private class PspdfkitApiPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AndroidPermissionStatus(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AnnotationType(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AnnotationTool(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AnnotationToolVariant(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AnnotationProcessingMode(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return DocumentPermissions(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PdfVersion(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PdfFormFieldTypes(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return NutrientEvent(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      return PdfRect.fromList(self.readValue() as! [Any?])
    case 139:
      return PageInfo.fromList(self.readValue() as! [Any?])
    case 140:
      return DocumentSaveOptions.fromList(self.readValue() as! [Any?])
    case 141:
      return PdfFormOption.fromList(self.readValue() as! [Any?])
    case 142:
      return FormFieldData.fromList(self.readValue() as! [Any?])
    case 143:
      return PointF.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class PspdfkitApiPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AndroidPermissionStatus {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? AnnotationType {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? AnnotationTool {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? AnnotationToolVariant {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? AnnotationProcessingMode {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? DocumentPermissions {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? PdfVersion {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? PdfFormFieldTypes {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? NutrientEvent {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? PdfRect {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? PageInfo {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? DocumentSaveOptions {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? PdfFormOption {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? FormFieldData {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? PointF {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PspdfkitApiPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PspdfkitApiPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PspdfkitApiPigeonCodecWriter(data: data)
  }
}

class PspdfkitApiPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = PspdfkitApiPigeonCodec(readerWriter: PspdfkitApiPigeonCodecReaderWriter())
}


/// The API for interacting with a PDF document.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PspdfkitApi {
  func getFrameworkVersion(completion: @escaping (Result<String?, Error>) -> Void)
  func setLicenseKey(licenseKey: String?, completion: @escaping (Result<Void, Error>) -> Void)
  func setLicenseKeys(androidLicenseKey: String?, iOSLicenseKey: String?, webLicenseKey: String?, completion: @escaping (Result<Void, Error>) -> Void)
  func present(document: String, configuration: [String: Any]?, completion: @escaping (Result<Bool?, Error>) -> Void)
  func presentInstant(serverUrl: String, jwt: String, configuration: [String: Any]?, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setFormFieldValue(value: String, fullyQualifiedName: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func getFormFieldValue(fullyQualifiedName: String, completion: @escaping (Result<String?, Error>) -> Void)
  func applyInstantJson(annotationsJson: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func exportInstantJson(completion: @escaping (Result<String?, Error>) -> Void)
  func addAnnotation(annotation: String, attachment: String?, completion: @escaping (Result<Bool?, Error>) -> Void)
  func removeAnnotation(annotation: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func getAnnotations(pageIndex: Int64, type: String, completion: @escaping (Result<Any?, Error>) -> Void)
  func getAllUnsavedAnnotations(completion: @escaping (Result<Any?, Error>) -> Void)
  func updateAnnotation(annotation: String, completion: @escaping (Result<Void, Error>) -> Void)
  func processAnnotations(type: AnnotationType, processingMode: AnnotationProcessingMode, destinationPath: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func importXfdf(xfdfString: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func exportXfdf(xfdfPath: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func save(completion: @escaping (Result<Bool?, Error>) -> Void)
  func setDelayForSyncingLocalChanges(delay: Double, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setListenToServerChanges(listen: Bool, completion: @escaping (Result<Bool?, Error>) -> Void)
  func syncAnnotations(completion: @escaping (Result<Bool?, Error>) -> Void)
  func checkAndroidWriteExternalStoragePermission(completion: @escaping (Result<Bool?, Error>) -> Void)
  func requestAndroidWriteExternalStoragePermission(completion: @escaping (Result<AndroidPermissionStatus, Error>) -> Void)
  func openAndroidSettings(completion: @escaping (Result<Void, Error>) -> Void)
  func setAnnotationPresetConfigurations(configurations: [String: Any?], completion: @escaping (Result<Bool?, Error>) -> Void)
  func getTemporaryDirectory(completion: @escaping (Result<String, Error>) -> Void)
  func setAuthorName(name: String, completion: @escaping (Result<Void, Error>) -> Void)
  func getAuthorName(completion: @escaping (Result<String, Error>) -> Void)
  /// Generate PDF from Images, Template, and Patterns.
  /// [pages]: [NewPage]s to be added to the PDF.
  /// [outputPath]: The path to the output file.
  /// Returns the path to the generated PDF path or null if the input is invalid or if the PDF generation fails.
  func generatePdf(pages: [[String: Any]], outputPath: String, completion: @escaping (Result<String?, Error>) -> Void)
  /// Generates a PDF from HTML string.
  ///
  /// [html]: The HTML string to be converted to PDF.
  /// [outPutFile]: The path to the output file.
  /// Returns the path to the generated PDF file or null if the input is invalid or if the PDF generation fails.
  func generatePdfFromHtmlString(html: String, outPutFile: String, options: [String: Any]?, completion: @escaping (Result<String?, Error>) -> Void)
  func generatePdfFromHtmlUri(htmlUri: String, outPutFile: String, options: [String: Any]?, completion: @escaping (Result<String?, Error>) -> Void)
  /// Configure Nutrient Analytics events.
  func enableAnalyticsEvents(enable: Bool) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PspdfkitApiSetup {
  static var codec: FlutterStandardMessageCodec { PspdfkitApiPigeonCodec.shared }
  /// Sets up an instance of `PspdfkitApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PspdfkitApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getFrameworkVersionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.getFrameworkVersion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFrameworkVersionChannel.setMessageHandler { _, reply in
        api.getFrameworkVersion { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFrameworkVersionChannel.setMessageHandler(nil)
    }
    let setLicenseKeyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setLicenseKey\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLicenseKeyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let licenseKeyArg: String? = nilOrValue(args[0])
        api.setLicenseKey(licenseKey: licenseKeyArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setLicenseKeyChannel.setMessageHandler(nil)
    }
    let setLicenseKeysChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setLicenseKeys\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLicenseKeysChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let androidLicenseKeyArg: String? = nilOrValue(args[0])
        let iOSLicenseKeyArg: String? = nilOrValue(args[1])
        let webLicenseKeyArg: String? = nilOrValue(args[2])
        api.setLicenseKeys(androidLicenseKey: androidLicenseKeyArg, iOSLicenseKey: iOSLicenseKeyArg, webLicenseKey: webLicenseKeyArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setLicenseKeysChannel.setMessageHandler(nil)
    }
    let presentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.present\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      presentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let documentArg = args[0] as! String
        let configurationArg: [String: Any]? = nilOrValue(args[1])
        api.present(document: documentArg, configuration: configurationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      presentChannel.setMessageHandler(nil)
    }
    let presentInstantChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.presentInstant\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      presentInstantChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let serverUrlArg = args[0] as! String
        let jwtArg = args[1] as! String
        let configurationArg: [String: Any]? = nilOrValue(args[2])
        api.presentInstant(serverUrl: serverUrlArg, jwt: jwtArg, configuration: configurationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      presentInstantChannel.setMessageHandler(nil)
    }
    let setFormFieldValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setFormFieldValue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFormFieldValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! String
        let fullyQualifiedNameArg = args[1] as! String
        api.setFormFieldValue(value: valueArg, fullyQualifiedName: fullyQualifiedNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFormFieldValueChannel.setMessageHandler(nil)
    }
    let getFormFieldValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.getFormFieldValue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFormFieldValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fullyQualifiedNameArg = args[0] as! String
        api.getFormFieldValue(fullyQualifiedName: fullyQualifiedNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFormFieldValueChannel.setMessageHandler(nil)
    }
    let applyInstantJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.applyInstantJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      applyInstantJsonChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationsJsonArg = args[0] as! String
        api.applyInstantJson(annotationsJson: annotationsJsonArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      applyInstantJsonChannel.setMessageHandler(nil)
    }
    let exportInstantJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.exportInstantJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportInstantJsonChannel.setMessageHandler { _, reply in
        api.exportInstantJson { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportInstantJsonChannel.setMessageHandler(nil)
    }
    let addAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.addAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationArg = args[0] as! String
        let attachmentArg: String? = nilOrValue(args[1])
        api.addAnnotation(annotation: annotationArg, attachment: attachmentArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addAnnotationChannel.setMessageHandler(nil)
    }
    let removeAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.removeAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationArg = args[0] as! String
        api.removeAnnotation(annotation: annotationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeAnnotationChannel.setMessageHandler(nil)
    }
    let getAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.getAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAnnotationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        let typeArg = args[1] as! String
        api.getAnnotations(pageIndex: pageIndexArg, type: typeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAnnotationsChannel.setMessageHandler(nil)
    }
    let getAllUnsavedAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.getAllUnsavedAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAllUnsavedAnnotationsChannel.setMessageHandler { _, reply in
        api.getAllUnsavedAnnotations { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAllUnsavedAnnotationsChannel.setMessageHandler(nil)
    }
    let updateAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.updateAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationArg = args[0] as! String
        api.updateAnnotation(annotation: annotationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateAnnotationChannel.setMessageHandler(nil)
    }
    let processAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.processAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      processAnnotationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let typeArg = args[0] as! AnnotationType
        let processingModeArg = args[1] as! AnnotationProcessingMode
        let destinationPathArg = args[2] as! String
        api.processAnnotations(type: typeArg, processingMode: processingModeArg, destinationPath: destinationPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      processAnnotationsChannel.setMessageHandler(nil)
    }
    let importXfdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.importXfdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      importXfdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfStringArg = args[0] as! String
        api.importXfdf(xfdfString: xfdfStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      importXfdfChannel.setMessageHandler(nil)
    }
    let exportXfdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.exportXfdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportXfdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfPathArg = args[0] as! String
        api.exportXfdf(xfdfPath: xfdfPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportXfdfChannel.setMessageHandler(nil)
    }
    let saveChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.save\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      saveChannel.setMessageHandler { _, reply in
        api.save { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      saveChannel.setMessageHandler(nil)
    }
    let setDelayForSyncingLocalChangesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setDelayForSyncingLocalChanges\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setDelayForSyncingLocalChangesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let delayArg = args[0] as! Double
        api.setDelayForSyncingLocalChanges(delay: delayArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setDelayForSyncingLocalChangesChannel.setMessageHandler(nil)
    }
    let setListenToServerChangesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setListenToServerChanges\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setListenToServerChangesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let listenArg = args[0] as! Bool
        api.setListenToServerChanges(listen: listenArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setListenToServerChangesChannel.setMessageHandler(nil)
    }
    let syncAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.syncAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      syncAnnotationsChannel.setMessageHandler { _, reply in
        api.syncAnnotations { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      syncAnnotationsChannel.setMessageHandler(nil)
    }
    let checkAndroidWriteExternalStoragePermissionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.checkAndroidWriteExternalStoragePermission\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      checkAndroidWriteExternalStoragePermissionChannel.setMessageHandler { _, reply in
        api.checkAndroidWriteExternalStoragePermission { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      checkAndroidWriteExternalStoragePermissionChannel.setMessageHandler(nil)
    }
    let requestAndroidWriteExternalStoragePermissionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.requestAndroidWriteExternalStoragePermission\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      requestAndroidWriteExternalStoragePermissionChannel.setMessageHandler { _, reply in
        api.requestAndroidWriteExternalStoragePermission { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      requestAndroidWriteExternalStoragePermissionChannel.setMessageHandler(nil)
    }
    let openAndroidSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.openAndroidSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      openAndroidSettingsChannel.setMessageHandler { _, reply in
        api.openAndroidSettings { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      openAndroidSettingsChannel.setMessageHandler(nil)
    }
    let setAnnotationPresetConfigurationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setAnnotationPresetConfigurations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAnnotationPresetConfigurationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let configurationsArg = args[0] as! [String: Any?]
        api.setAnnotationPresetConfigurations(configurations: configurationsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setAnnotationPresetConfigurationsChannel.setMessageHandler(nil)
    }
    let getTemporaryDirectoryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.getTemporaryDirectory\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTemporaryDirectoryChannel.setMessageHandler { _, reply in
        api.getTemporaryDirectory { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTemporaryDirectoryChannel.setMessageHandler(nil)
    }
    let setAuthorNameChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.setAuthorName\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAuthorNameChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let nameArg = args[0] as! String
        api.setAuthorName(name: nameArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setAuthorNameChannel.setMessageHandler(nil)
    }
    let getAuthorNameChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.getAuthorName\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAuthorNameChannel.setMessageHandler { _, reply in
        api.getAuthorName { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAuthorNameChannel.setMessageHandler(nil)
    }
    /// Generate PDF from Images, Template, and Patterns.
    /// [pages]: [NewPage]s to be added to the PDF.
    /// [outputPath]: The path to the output file.
    /// Returns the path to the generated PDF path or null if the input is invalid or if the PDF generation fails.
    let generatePdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.generatePdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      generatePdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pagesArg = args[0] as! [[String: Any]]
        let outputPathArg = args[1] as! String
        api.generatePdf(pages: pagesArg, outputPath: outputPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      generatePdfChannel.setMessageHandler(nil)
    }
    /// Generates a PDF from HTML string.
    ///
    /// [html]: The HTML string to be converted to PDF.
    /// [outPutFile]: The path to the output file.
    /// Returns the path to the generated PDF file or null if the input is invalid or if the PDF generation fails.
    let generatePdfFromHtmlStringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.generatePdfFromHtmlString\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      generatePdfFromHtmlStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let htmlArg = args[0] as! String
        let outPutFileArg = args[1] as! String
        let optionsArg: [String: Any]? = nilOrValue(args[2])
        api.generatePdfFromHtmlString(html: htmlArg, outPutFile: outPutFileArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      generatePdfFromHtmlStringChannel.setMessageHandler(nil)
    }
    let generatePdfFromHtmlUriChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.generatePdfFromHtmlUri\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      generatePdfFromHtmlUriChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let htmlUriArg = args[0] as! String
        let outPutFileArg = args[1] as! String
        let optionsArg: [String: Any]? = nilOrValue(args[2])
        api.generatePdfFromHtmlUri(htmlUri: htmlUriArg, outPutFile: outPutFileArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      generatePdfFromHtmlUriChannel.setMessageHandler(nil)
    }
    /// Configure Nutrient Analytics events.
    let enableAnalyticsEventsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitApi.enableAnalyticsEvents\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enableAnalyticsEventsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let enableArg = args[0] as! Bool
        do {
          try api.enableAnalyticsEvents(enable: enableArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      enableAnalyticsEventsChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol PspdfkitFlutterApiCallbacksProtocol {
  /// onPAuse callback for FlutterPdfActivity
  func onPdfActivityOnPause(completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  func onPdfFragmentAdded(completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  func onDocumentLoaded(documentId documentIdArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  /// ViewControllerWillDismiss callback for PDFViewController
  func onPdfViewControllerWillDismiss(completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  /// ViewControllerDidDismiss callback for PDFViewController
  func onPdfViewControllerDidDismiss(completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  /// Called when instant synchronization starts.
  func onInstantSyncStarted(documentId documentIdArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  /// Called when instant synchronization ends.
  func onInstantSyncFinished(documentId documentIdArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  /// Called when instant synchronization fails.
  func onInstantSyncFailed(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  /// Called when instant authentication is done.
  func onInstantAuthenticationFinished(documentId documentIdArg: String, validJWT validJWTArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  /// Called when instant authentication fails.
  func onInstantAuthenticationFailed(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  /// Only available on iOS.
  /// Called when instant document download is done.
  func onInstantDownloadFinished(documentId documentIdArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  /// Only available on iOS.
  /// Called when instant document download fails.
  func onInstantDownloadFailed(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
}
class PspdfkitFlutterApiCallbacks: PspdfkitFlutterApiCallbacksProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PspdfkitApiPigeonCodec {
    return PspdfkitApiPigeonCodec.shared
  }
  /// onPAuse callback for FlutterPdfActivity
  func onPdfActivityOnPause(completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onPdfActivityOnPause\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onPdfFragmentAdded(completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onPdfFragmentAdded\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onDocumentLoaded(documentId documentIdArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onDocumentLoaded\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// ViewControllerWillDismiss callback for PDFViewController
  func onPdfViewControllerWillDismiss(completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onPdfViewControllerWillDismiss\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// ViewControllerDidDismiss callback for PDFViewController
  func onPdfViewControllerDidDismiss(completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onPdfViewControllerDidDismiss\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Called when instant synchronization starts.
  func onInstantSyncStarted(documentId documentIdArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantSyncStarted\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Called when instant synchronization ends.
  func onInstantSyncFinished(documentId documentIdArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantSyncFinished\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Called when instant synchronization fails.
  func onInstantSyncFailed(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantSyncFailed\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Called when instant authentication is done.
  func onInstantAuthenticationFinished(documentId documentIdArg: String, validJWT validJWTArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantAuthenticationFinished\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, validJWTArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Called when instant authentication fails.
  func onInstantAuthenticationFailed(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantAuthenticationFailed\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Only available on iOS.
  /// Called when instant document download is done.
  func onInstantDownloadFinished(documentId documentIdArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantDownloadFinished\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Only available on iOS.
  /// Called when instant document download fails.
  func onInstantDownloadFailed(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitFlutterApiCallbacks.onInstantDownloadFailed\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PspdfkitWidgetControllerApi {
  /// Sets the value of a form field by specifying its fully qualified field name.
  /// This method is deprecated. Use [PdfDocument.setFormFieldValue] instead.
  func setFormFieldValue(value: String, fullyQualifiedName: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Gets the form field value by specifying its fully qualified name.
  func getFormFieldValue(fullyQualifiedName: String, completion: @escaping (Result<String?, Error>) -> Void)
  /// Applies Instant document JSON to the presented document.
  func applyInstantJson(annotationsJson: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Exports Instant document JSON from the presented document.
  func exportInstantJson(completion: @escaping (Result<String?, Error>) -> Void)
  /// Adds the given annotation to the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  func addAnnotation(annotation: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Removes the given annotation from the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  func removeAnnotation(annotation: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Returns a list of JSON dictionaries for all the annotations of the given `type` on the given `pageIndex`.
  func getAnnotations(pageIndex: Int64, type: String, completion: @escaping (Result<Any, Error>) -> Void)
  /// Returns a list of JSON dictionaries for all the unsaved annotations in the presented document.
  func getAllUnsavedAnnotations(completion: @escaping (Result<Any, Error>) -> Void)
  /// Processes annotations of the given type with the provided processing
  /// mode and stores the PDF at the given destination path.
  func processAnnotations(type: AnnotationType, processingMode: AnnotationProcessingMode, destinationPath: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Imports annotations from the XFDF file at the given path.
  func importXfdf(xfdfString: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Exports annotations to the XFDF file at the given path.
  func exportXfdf(xfdfPath: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Saves the document back to its original location if it has been changed.
  /// If there were no changes to the document, the document file will not be modified.
  func save(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Sets the annotation preset configurations for the given annotation tools.
  /// @param configurations A map of annotation tools and their corresponding configurations.
  /// @param modifyAssociatedAnnotations Whether to modify the annotations associated with the old configuration. Only used for Android.
  /// @return True if the configurations were set successfully, false otherwise.
  func setAnnotationConfigurations(configurations: [String: [String: Any]], completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Gets the visible rect of the given page.
  /// pageIndex The index of the page. This is a zero-based index.
  /// Returns a [Future] that completes with the visible rect of the given page.
  func getVisibleRect(pageIndex: Int64, completion: @escaping (Result<PdfRect, Error>) -> Void)
  /// Zooms to the given rect on the given page.
  /// pageIndex The index of the page. This is a zero-based index.
  /// rect The rect to zoom to.
  /// Returns a [Future] that completes when the zoom operation is done.
  func zoomToRect(pageIndex: Int64, rect: PdfRect, animated: Bool?, duration: Double?, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Gets the zoom scale of the given page.
  /// pageIndex The index of the page. This is a zero-based index.
  /// Returns a [Future] that completes with the zoom scale of the given page.
  func getZoomScale(pageIndex: Int64, completion: @escaping (Result<Double, Error>) -> Void)
  func addEventListener(event: NutrientEvent) throws
  func removeEventListener(event: NutrientEvent) throws
  /// Enters annotation creation mode.
  ///
  /// If [annotationTool] is provided, that specific tool will be activated.
  /// If no tool is provided, the default annotation tool will be used.
  ///
  /// Returns a [Future] that completes with a boolean indicating whether
  /// entering annotation creation mode was successful.
  func enterAnnotationCreationMode(annotationTool: AnnotationTool?, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Exits annotation creation mode.
  ///
  /// Returns a [Future] that completes with a boolean indicating whether
  /// exiting annotation creation mode was successful.
  func exitAnnotationCreationMode(completion: @escaping (Result<Bool?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PspdfkitWidgetControllerApiSetup {
  static var codec: FlutterStandardMessageCodec { PspdfkitApiPigeonCodec.shared }
  /// Sets up an instance of `PspdfkitWidgetControllerApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PspdfkitWidgetControllerApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Sets the value of a form field by specifying its fully qualified field name.
    /// This method is deprecated. Use [PdfDocument.setFormFieldValue] instead.
    let setFormFieldValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.setFormFieldValue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFormFieldValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! String
        let fullyQualifiedNameArg = args[1] as! String
        api.setFormFieldValue(value: valueArg, fullyQualifiedName: fullyQualifiedNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFormFieldValueChannel.setMessageHandler(nil)
    }
    /// Gets the form field value by specifying its fully qualified name.
    let getFormFieldValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.getFormFieldValue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFormFieldValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fullyQualifiedNameArg = args[0] as! String
        api.getFormFieldValue(fullyQualifiedName: fullyQualifiedNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFormFieldValueChannel.setMessageHandler(nil)
    }
    /// Applies Instant document JSON to the presented document.
    let applyInstantJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.applyInstantJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      applyInstantJsonChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationsJsonArg = args[0] as! String
        api.applyInstantJson(annotationsJson: annotationsJsonArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      applyInstantJsonChannel.setMessageHandler(nil)
    }
    /// Exports Instant document JSON from the presented document.
    let exportInstantJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.exportInstantJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportInstantJsonChannel.setMessageHandler { _, reply in
        api.exportInstantJson { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportInstantJsonChannel.setMessageHandler(nil)
    }
    /// Adds the given annotation to the presented document.
    /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
    let addAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.addAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationArg = args[0] as! String
        api.addAnnotation(annotation: annotationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addAnnotationChannel.setMessageHandler(nil)
    }
    /// Removes the given annotation from the presented document.
    /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
    let removeAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.removeAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationArg = args[0] as! String
        api.removeAnnotation(annotation: annotationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeAnnotationChannel.setMessageHandler(nil)
    }
    /// Returns a list of JSON dictionaries for all the annotations of the given `type` on the given `pageIndex`.
    let getAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.getAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAnnotationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        let typeArg = args[1] as! String
        api.getAnnotations(pageIndex: pageIndexArg, type: typeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAnnotationsChannel.setMessageHandler(nil)
    }
    /// Returns a list of JSON dictionaries for all the unsaved annotations in the presented document.
    let getAllUnsavedAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.getAllUnsavedAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAllUnsavedAnnotationsChannel.setMessageHandler { _, reply in
        api.getAllUnsavedAnnotations { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAllUnsavedAnnotationsChannel.setMessageHandler(nil)
    }
    /// Processes annotations of the given type with the provided processing
    /// mode and stores the PDF at the given destination path.
    let processAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.processAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      processAnnotationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let typeArg = args[0] as! AnnotationType
        let processingModeArg = args[1] as! AnnotationProcessingMode
        let destinationPathArg = args[2] as! String
        api.processAnnotations(type: typeArg, processingMode: processingModeArg, destinationPath: destinationPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      processAnnotationsChannel.setMessageHandler(nil)
    }
    /// Imports annotations from the XFDF file at the given path.
    let importXfdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.importXfdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      importXfdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfStringArg = args[0] as! String
        api.importXfdf(xfdfString: xfdfStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      importXfdfChannel.setMessageHandler(nil)
    }
    /// Exports annotations to the XFDF file at the given path.
    let exportXfdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.exportXfdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportXfdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfPathArg = args[0] as! String
        api.exportXfdf(xfdfPath: xfdfPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportXfdfChannel.setMessageHandler(nil)
    }
    /// Saves the document back to its original location if it has been changed.
    /// If there were no changes to the document, the document file will not be modified.
    let saveChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.save\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      saveChannel.setMessageHandler { _, reply in
        api.save { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      saveChannel.setMessageHandler(nil)
    }
    /// Sets the annotation preset configurations for the given annotation tools.
    /// @param configurations A map of annotation tools and their corresponding configurations.
    /// @param modifyAssociatedAnnotations Whether to modify the annotations associated with the old configuration. Only used for Android.
    /// @return True if the configurations were set successfully, false otherwise.
    let setAnnotationConfigurationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.setAnnotationConfigurations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAnnotationConfigurationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let configurationsArg = args[0] as! [String: [String: Any]]
        api.setAnnotationConfigurations(configurations: configurationsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setAnnotationConfigurationsChannel.setMessageHandler(nil)
    }
    /// Gets the visible rect of the given page.
    /// pageIndex The index of the page. This is a zero-based index.
    /// Returns a [Future] that completes with the visible rect of the given page.
    let getVisibleRectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.getVisibleRect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVisibleRectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        api.getVisibleRect(pageIndex: pageIndexArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getVisibleRectChannel.setMessageHandler(nil)
    }
    /// Zooms to the given rect on the given page.
    /// pageIndex The index of the page. This is a zero-based index.
    /// rect The rect to zoom to.
    /// Returns a [Future] that completes when the zoom operation is done.
    let zoomToRectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.zoomToRect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      zoomToRectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        let rectArg = args[1] as! PdfRect
        let animatedArg: Bool? = nilOrValue(args[2])
        let durationArg: Double? = nilOrValue(args[3])
        api.zoomToRect(pageIndex: pageIndexArg, rect: rectArg, animated: animatedArg, duration: durationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      zoomToRectChannel.setMessageHandler(nil)
    }
    /// Gets the zoom scale of the given page.
    /// pageIndex The index of the page. This is a zero-based index.
    /// Returns a [Future] that completes with the zoom scale of the given page.
    let getZoomScaleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.getZoomScale\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getZoomScaleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        api.getZoomScale(pageIndex: pageIndexArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getZoomScaleChannel.setMessageHandler(nil)
    }
    let addEventListenerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.addEventListener\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addEventListenerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let eventArg = args[0] as! NutrientEvent
        do {
          try api.addEventListener(event: eventArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addEventListenerChannel.setMessageHandler(nil)
    }
    let removeEventListenerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.removeEventListener\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeEventListenerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let eventArg = args[0] as! NutrientEvent
        do {
          try api.removeEventListener(event: eventArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeEventListenerChannel.setMessageHandler(nil)
    }
    /// Enters annotation creation mode.
    ///
    /// If [annotationTool] is provided, that specific tool will be activated.
    /// If no tool is provided, the default annotation tool will be used.
    ///
    /// Returns a [Future] that completes with a boolean indicating whether
    /// entering annotation creation mode was successful.
    let enterAnnotationCreationModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.enterAnnotationCreationMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enterAnnotationCreationModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationToolArg: AnnotationTool? = nilOrValue(args[0])
        api.enterAnnotationCreationMode(annotationTool: annotationToolArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      enterAnnotationCreationModeChannel.setMessageHandler(nil)
    }
    /// Exits annotation creation mode.
    ///
    /// Returns a [Future] that completes with a boolean indicating whether
    /// exiting annotation creation mode was successful.
    let exitAnnotationCreationModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetControllerApi.exitAnnotationCreationMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exitAnnotationCreationModeChannel.setMessageHandler { _, reply in
        api.exitAnnotationCreationMode { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exitAnnotationCreationModeChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PdfDocumentApi {
  /// Returns the page info for the given page index.
  /// pageIndex The index of the page. This is a zero-based index.
  func getPageInfo(pageIndex: Int64, completion: @escaping (Result<PageInfo, Error>) -> Void)
  /// Exports the document as a PDF.
  /// options:[DocumentSaveOptions] The options to use when exporting the document.
  /// Returns a [Uint8List] containing the exported PDF data.
  func exportPdf(options: DocumentSaveOptions?, completion: @escaping (Result<FlutterStandardTypedData, Error>) -> Void)
  func getFormField(fieldName: String, completion: @escaping (Result<[String: Any?], Error>) -> Void)
  /// Returns a list of all form fields in the document.
  func getFormFields(completion: @escaping (Result<[[String: Any?]], Error>) -> Void)
  /// Sets the value of a form field by specifying its fully qualified field name.
  func setFormFieldValue(value: String, fullyQualifiedName: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Gets the form field value by specifying its fully qualified name.
  func getFormFieldValue(fullyQualifiedName: String, completion: @escaping (Result<String?, Error>) -> Void)
  /// Applies Instant document JSON to the presented document.
  func applyInstantJson(annotationsJson: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Exports Instant document JSON from the presented document.
  func exportInstantJson(completion: @escaping (Result<String?, Error>) -> Void)
  /// Adds the given annotation to the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  func addAnnotation(jsonAnnotation: String, attachment: Any?, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Updates the given annotation in the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  func updateAnnotation(jsonAnnotation: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Removes the given annotation from the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  func removeAnnotation(jsonAnnotation: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Returns a list of JSON dictionaries for all the annotations of the given `type` on the given `pageIndex`.
  func getAnnotations(pageIndex: Int64, type: String, completion: @escaping (Result<Any, Error>) -> Void)
  /// Returns a list of JSON dictionaries for all the unsaved annotations in the presented document.
  func getAllUnsavedAnnotations(completion: @escaping (Result<Any, Error>) -> Void)
  /// Imports annotations from the XFDF file at the given path.
  func importXfdf(xfdfString: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Exports annotations to the XFDF file at the given path.
  func exportXfdf(xfdfPath: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Saves the document back to its original location if it has been changed.
  /// If there were no changes to the document, the document file will not be modified.
  func save(outputPath: String?, options: DocumentSaveOptions?, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Get the total number of pages in the document.
  func getPageCount(completion: @escaping (Result<Int64, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PdfDocumentApiSetup {
  static var codec: FlutterStandardMessageCodec { PspdfkitApiPigeonCodec.shared }
  /// Sets up an instance of `PdfDocumentApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PdfDocumentApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Returns the page info for the given page index.
    /// pageIndex The index of the page. This is a zero-based index.
    let getPageInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getPageInfo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPageInfoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        api.getPageInfo(pageIndex: pageIndexArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getPageInfoChannel.setMessageHandler(nil)
    }
    /// Exports the document as a PDF.
    /// options:[DocumentSaveOptions] The options to use when exporting the document.
    /// Returns a [Uint8List] containing the exported PDF data.
    let exportPdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.exportPdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportPdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg: DocumentSaveOptions? = nilOrValue(args[0])
        api.exportPdf(options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportPdfChannel.setMessageHandler(nil)
    }
    let getFormFieldChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getFormField\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFormFieldChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fieldNameArg = args[0] as! String
        api.getFormField(fieldName: fieldNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFormFieldChannel.setMessageHandler(nil)
    }
    /// Returns a list of all form fields in the document.
    let getFormFieldsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getFormFields\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFormFieldsChannel.setMessageHandler { _, reply in
        api.getFormFields { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFormFieldsChannel.setMessageHandler(nil)
    }
    /// Sets the value of a form field by specifying its fully qualified field name.
    let setFormFieldValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.setFormFieldValue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFormFieldValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! String
        let fullyQualifiedNameArg = args[1] as! String
        api.setFormFieldValue(value: valueArg, fullyQualifiedName: fullyQualifiedNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFormFieldValueChannel.setMessageHandler(nil)
    }
    /// Gets the form field value by specifying its fully qualified name.
    let getFormFieldValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getFormFieldValue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFormFieldValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fullyQualifiedNameArg = args[0] as! String
        api.getFormFieldValue(fullyQualifiedName: fullyQualifiedNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFormFieldValueChannel.setMessageHandler(nil)
    }
    /// Applies Instant document JSON to the presented document.
    let applyInstantJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.applyInstantJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      applyInstantJsonChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationsJsonArg = args[0] as! String
        api.applyInstantJson(annotationsJson: annotationsJsonArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      applyInstantJsonChannel.setMessageHandler(nil)
    }
    /// Exports Instant document JSON from the presented document.
    let exportInstantJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.exportInstantJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportInstantJsonChannel.setMessageHandler { _, reply in
        api.exportInstantJson { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportInstantJsonChannel.setMessageHandler(nil)
    }
    /// Adds the given annotation to the presented document.
    /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
    let addAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.addAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let jsonAnnotationArg = args[0] as! String
        let attachmentArg: Any? = args[1]
        api.addAnnotation(jsonAnnotation: jsonAnnotationArg, attachment: attachmentArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addAnnotationChannel.setMessageHandler(nil)
    }
    /// Updates the given annotation in the presented document.
    /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
    let updateAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.updateAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let jsonAnnotationArg = args[0] as! String
        api.updateAnnotation(jsonAnnotation: jsonAnnotationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateAnnotationChannel.setMessageHandler(nil)
    }
    /// Removes the given annotation from the presented document.
    /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
    let removeAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.removeAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let jsonAnnotationArg = args[0] as! String
        api.removeAnnotation(jsonAnnotation: jsonAnnotationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeAnnotationChannel.setMessageHandler(nil)
    }
    /// Returns a list of JSON dictionaries for all the annotations of the given `type` on the given `pageIndex`.
    let getAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAnnotationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        let typeArg = args[1] as! String
        api.getAnnotations(pageIndex: pageIndexArg, type: typeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAnnotationsChannel.setMessageHandler(nil)
    }
    /// Returns a list of JSON dictionaries for all the unsaved annotations in the presented document.
    let getAllUnsavedAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getAllUnsavedAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAllUnsavedAnnotationsChannel.setMessageHandler { _, reply in
        api.getAllUnsavedAnnotations { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAllUnsavedAnnotationsChannel.setMessageHandler(nil)
    }
    /// Imports annotations from the XFDF file at the given path.
    let importXfdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.importXfdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      importXfdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfStringArg = args[0] as! String
        api.importXfdf(xfdfString: xfdfStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      importXfdfChannel.setMessageHandler(nil)
    }
    /// Exports annotations to the XFDF file at the given path.
    let exportXfdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.exportXfdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportXfdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfPathArg = args[0] as! String
        api.exportXfdf(xfdfPath: xfdfPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportXfdfChannel.setMessageHandler(nil)
    }
    /// Saves the document back to its original location if it has been changed.
    /// If there were no changes to the document, the document file will not be modified.
    let saveChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.save\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      saveChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let outputPathArg: String? = nilOrValue(args[0])
        let optionsArg: DocumentSaveOptions? = nilOrValue(args[1])
        api.save(outputPath: outputPathArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      saveChannel.setMessageHandler(nil)
    }
    /// Get the total number of pages in the document.
    let getPageCountChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pspdfkit_flutter.PdfDocumentApi.getPageCount\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPageCountChannel.setMessageHandler { _, reply in
        api.getPageCount { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getPageCountChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol PspdfkitWidgetCallbacksProtocol {
  func onDocumentLoaded(documentId documentIdArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  func onDocumentError(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  func onPageChanged(documentId documentIdArg: String, pageIndex pageIndexArg: Int64, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  func onPageClick(documentId documentIdArg: String, pageIndex pageIndexArg: Int64, point pointArg: PointF?, annotation annotationArg: Any?, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
  func onDocumentSaved(documentId documentIdArg: String, path pathArg: String?, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
}
class PspdfkitWidgetCallbacks: PspdfkitWidgetCallbacksProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PspdfkitApiPigeonCodec {
    return PspdfkitApiPigeonCodec.shared
  }
  func onDocumentLoaded(documentId documentIdArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetCallbacks.onDocumentLoaded\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onDocumentError(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetCallbacks.onDocumentError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onPageChanged(documentId documentIdArg: String, pageIndex pageIndexArg: Int64, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetCallbacks.onPageChanged\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, pageIndexArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onPageClick(documentId documentIdArg: String, pageIndex pageIndexArg: Int64, point pointArg: PointF?, annotation annotationArg: Any?, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetCallbacks.onPageClick\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, pageIndexArg, pointArg, annotationArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onDocumentSaved(documentId documentIdArg: String, path pathArg: String?, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.PspdfkitWidgetCallbacks.onDocumentSaved\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, pathArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol NutrientEventsCallbacksProtocol {
  func onEvent(event eventArg: NutrientEvent, data dataArg: Any?, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
}
class NutrientEventsCallbacks: NutrientEventsCallbacksProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PspdfkitApiPigeonCodec {
    return PspdfkitApiPigeonCodec.shared
  }
  func onEvent(event eventArg: NutrientEvent, data dataArg: Any?, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.NutrientEventsCallbacks.onEvent\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([eventArg, dataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol AnalyticsEventsCallbackProtocol {
  func onEvent(event eventArg: String, attributes attributesArg: [String: Any?]?, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
}
class AnalyticsEventsCallback: AnalyticsEventsCallbackProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PspdfkitApiPigeonCodec {
    return PspdfkitApiPigeonCodec.shared
  }
  func onEvent(event eventArg: String, attributes attributesArg: [String: Any?]?, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.AnalyticsEventsCallback.onEvent\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([eventArg, attributesArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Callbacks for custom toolbar item interactions
///
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol CustomToolbarCallbacksProtocol {
  /// Called when a custom toolbar item is tapped
  func onCustomToolbarItemTapped(identifier identifierArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void)
}
class CustomToolbarCallbacks: CustomToolbarCallbacksProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PspdfkitApiPigeonCodec {
    return PspdfkitApiPigeonCodec.shared
  }
  /// Called when a custom toolbar item is tapped
  func onCustomToolbarItemTapped(identifier identifierArg: String, completion: @escaping (Result<Void, PspdfkitApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pspdfkit_flutter.CustomToolbarCallbacks.onCustomToolbarItemTapped\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([identifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PspdfkitApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
