// Copyright Â© 2024-2025 PSPDFKit GmbH. All rights reserved.
//
// THIS SOURCE CODE AND ANY ACCOMPANYING DOCUMENTATION ARE PROTECTED BY INTERNATIONAL COPYRIGHT LAW
// AND MAY NOT BE RESOLD OR REDISTRIBUTED. USAGE IS BOUND TO THE PSPDFKIT LICENSE AGREEMENT.
// UNAUTHORIZED REPRODUCTION OR DISTRIBUTION IS SUBJECT TO CIVIL AND CRIMINAL PENALTIES.
// This notice may not be removed from this file.
// Autogenerated from Pigeon (v24.2.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class NutrientApiError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "NutrientApiError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? NutrientApiError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> NutrientApiError {
  return NutrientApiError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum AndroidPermissionStatus: Int {
  case notDetermined = 0
  case denied = 1
  case authorized = 2
  case deniedNeverAsk = 3
}

/// Represents the native annotation type.
enum AnnotationType: Int {
  case all = 0
  case none = 1
  case undefined = 2
  case link = 3
  case highlight = 4
  case strikeout = 5
  case underline = 6
  case squiggly = 7
  case freeText = 8
  case ink = 9
  case square = 10
  case circle = 11
  case line = 12
  case note = 13
  case stamp = 14
  case caret = 15
  case media = 16
  case screen = 17
  case widget = 18
  case file = 19
  case sound = 20
  case polygon = 21
  case polyline = 22
  case popup = 23
  case watermark = 24
  case trapNet = 25
  case type3d = 26
  case redact = 27
  case image = 28
}

enum AnnotationTool: Int {
  case inkPen = 0
  case inkMagic = 1
  case inkHighlighter = 2
  case freeText = 3
  case freeTextCallOut = 4
  case stamp = 5
  case image = 6
  case highlight = 7
  case underline = 8
  case squiggly = 9
  case strikeOut = 10
  case line = 11
  case arrow = 12
  case square = 13
  case circle = 14
  case polygon = 15
  case polyline = 16
  case eraser = 17
  case cloudy = 18
  case link = 19
  case caret = 20
  case richMedia = 21
  case screen = 22
  case file = 23
  case widget = 24
  case redaction = 25
  case signature = 26
  case stampImage = 27
  case note = 28
  case sound = 29
  case measurementAreaRect = 30
  case measurementAreaPolygon = 31
  case measurementAreaEllipse = 32
  case measurementPerimeter = 33
  case measurementDistance = 34
}

enum AnnotationToolVariant: Int {
  case inkPen = 0
  case inkMagic = 1
  case inkHighlighter = 2
  case freeText = 3
  case freeTextCallOut = 4
  case stamp = 5
  case image = 6
  case highlight = 7
  case underline = 8
}

enum AnnotationProcessingMode: Int {
  case flatten = 0
  case remove = 1
  case embed = 2
  case print = 3
}

enum DocumentPermissions: Int {
  /// Allow printing of document.
  case printing = 0
  /// Modify the contents of the document.
  case modification = 1
  /// Copy text and images from the document.
  case extract = 2
  /// Add or modify text annotations, fill in interactive form fields.
  case annotationsAndForms = 3
  /// Fill in existing interactive form fields (including signature fields).
  case fillForms = 4
  /// Extract text and images from the document.
  case extractAccessibility = 5
  /// Assemble the document (insert, rotate, or delete pages and create document outline items or thumbnail images).
  case assemble = 6
  /// Print high quality.
  case printHighQuality = 7
}

/// The PDF version of a document.
enum PdfVersion: Int {
  case pdf10 = 0
  case pdf11 = 1
  case pdf12 = 2
  case pdf13 = 3
  case pdf14 = 4
  case pdf15 = 5
  case pdf16 = 6
  case pdf17 = 7
}

enum PdfFormFieldTypes: Int {
  case text = 0
  case checkbox = 1
  case radioButton = 2
  case comboBox = 3
  case listBox = 4
  case signature = 5
  case button = 6
  case unknown = 7
}

enum NutrientEvent: Int {
  /// Event triggered when annotations are created.
  case annotationsCreated = 0
  /// Event triggered when annotations are pressed.
  case annotationsDeselected = 1
  /// Event triggered when annotations are updated.
  case annotationsUpdated = 2
  /// Event triggered when annotations are deleted.
  case annotationsDeleted = 3
  /// Event triggered when annotations are focused.
  case annotationsSelected = 4
  /// Event triggered when form field values are updated.
  case formFieldValuesUpdated = 5
  /// Event triggered when form fields are loaded.
  case formFieldSelected = 6
  /// Event triggered when form fields are about to be saved.
  case formFieldDeselected = 7
  /// Event triggered when text selection changes.
  case textSelectionChanged = 8
}

/// Enumeration of default annotation menu actions that can be removed or disabled.
///
/// **Platform Support:**
/// - All actions can be removed or disabled on both iOS and Android
/// - Some system actions (copy/paste) may be harder to remove on iOS due to system restrictions
enum AnnotationMenuAction: Int {
  /// Delete action - removes the annotation
  /// - iOS: Part of UIMenu system actions
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_delete
  case delete = 0
  /// Copy action - copies the annotation
  /// - iOS: System copy action (may be harder to remove)
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_copy
  case copy = 1
  /// Cut action - cuts the annotation to clipboard
  /// - iOS: System cut action
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_cut
  case cut = 2
  /// Color action - opens annotation color picker/inspector
  /// - iOS: Style picker in UIMenu
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_picker
  case color = 3
  /// Note action - opens annotation note editor
  /// - iOS: Note action in UIMenu
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_annotation_note
  case note = 4
  /// Undo action - undoes the last action
  /// - iOS: Undo in UIMenu
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_undo
  case undo = 5
  /// Redo action - redoes the previously undone action
  /// - iOS: Redo in UIMenu
  /// - Android: R.id.pspdf__annotation_editing_toolbar_item_redo
  case redo = 6
}

/// Generated class from Pigeon that represents data sent in messages.
struct PdfRect {
  var x: Double
  var y: Double
  var width: Double
  var height: Double


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PdfRect? {
    let x = pigeonVar_list[0] as! Double
    let y = pigeonVar_list[1] as! Double
    let width = pigeonVar_list[2] as! Double
    let height = pigeonVar_list[3] as! Double

    return PdfRect(
      x: x,
      y: y,
      width: width,
      height: height
    )
  }
  func toList() -> [Any?] {
    return [
      x,
      y,
      width,
      height,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PageInfo {
  /// The index of the page. This is a zero-based index.
  var pageIndex: Int64
  /// The height of the page in points.
  var height: Double
  /// The width of the page in points.
  var width: Double
  /// The rotation of the page in degrees.
  var rotation: Int64
  /// The label of the page.
  var label: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PageInfo? {
    let pageIndex = pigeonVar_list[0] as! Int64
    let height = pigeonVar_list[1] as! Double
    let width = pigeonVar_list[2] as! Double
    let rotation = pigeonVar_list[3] as! Int64
    let label = pigeonVar_list[4] as! String

    return PageInfo(
      pageIndex: pageIndex,
      height: height,
      width: width,
      rotation: rotation,
      label: label
    )
  }
  func toList() -> [Any?] {
    return [
      pageIndex,
      height,
      width,
      rotation,
      label,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct DocumentSaveOptions {
  /// The password is used to encrypt the document. On Web, it's used as the user password.
  var userPassword: String? = nil
  /// The owner password is used to encrypt the document and set permissions. It's only used on Web.
  var ownerPassword: String? = nil
  /// Flatten annotations and form fields into the page content.
  var flatten: Bool? = nil
  /// Whether to save the document incrementally.
  var incremental: Bool? = nil
  /// The permissions to set on the document. See [DocumentPermissions] for more information.
  var permissions: [DocumentPermissions?]? = nil
  /// The PDF version to save the document as.
  var pdfVersion: PdfVersion? = nil
  /// Whether to exclude annotations from the exported document.
  var excludeAnnotations: Bool? = nil
  /// Whether to exclude annotations that have the noPrint flag set to true from the exported document (Standalone only)
  var saveForPrinting: Bool? = nil
  /// Whether to include comments in the exported document (Server-Backed only).
  var includeComments: Bool? = nil
  /// Whether tp allow you to export a PDF in PDF/A format.
  var outputFormat: Any? = nil
  /// Whether to optimize the document for the web.
  var optimize: Bool? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DocumentSaveOptions? {
    let userPassword: String? = nilOrValue(pigeonVar_list[0])
    let ownerPassword: String? = nilOrValue(pigeonVar_list[1])
    let flatten: Bool? = nilOrValue(pigeonVar_list[2])
    let incremental: Bool? = nilOrValue(pigeonVar_list[3])
    let permissions: [DocumentPermissions?]? = nilOrValue(pigeonVar_list[4])
    let pdfVersion: PdfVersion? = nilOrValue(pigeonVar_list[5])
    let excludeAnnotations: Bool? = nilOrValue(pigeonVar_list[6])
    let saveForPrinting: Bool? = nilOrValue(pigeonVar_list[7])
    let includeComments: Bool? = nilOrValue(pigeonVar_list[8])
    let outputFormat: Any? = pigeonVar_list[9]
    let optimize: Bool? = nilOrValue(pigeonVar_list[10])

    return DocumentSaveOptions(
      userPassword: userPassword,
      ownerPassword: ownerPassword,
      flatten: flatten,
      incremental: incremental,
      permissions: permissions,
      pdfVersion: pdfVersion,
      excludeAnnotations: excludeAnnotations,
      saveForPrinting: saveForPrinting,
      includeComments: includeComments,
      outputFormat: outputFormat,
      optimize: optimize
    )
  }
  func toList() -> [Any?] {
    return [
      userPassword,
      ownerPassword,
      flatten,
      incremental,
      permissions,
      pdfVersion,
      excludeAnnotations,
      saveForPrinting,
      includeComments,
      outputFormat,
      optimize,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PdfFormOption {
  /// The value of the option.
  var value: String
  /// The label of the option.
  var label: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PdfFormOption? {
    let value = pigeonVar_list[0] as! String
    let label = pigeonVar_list[1] as! String

    return PdfFormOption(
      value: value,
      label: label
    )
  }
  func toList() -> [Any?] {
    return [
      value,
      label,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct FormFieldData {
  var name: String
  var alternativeFieldName: String? = nil
  var fullyQualifiedName: String? = nil
  var type: PdfFormFieldTypes
  var annotations: Any? = nil
  var isReadOnly: Bool? = nil
  var isRequired: Bool? = nil
  var isExported: Bool? = nil
  var isDirty: Bool? = nil
  var options: [PdfFormOption?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> FormFieldData? {
    let name = pigeonVar_list[0] as! String
    let alternativeFieldName: String? = nilOrValue(pigeonVar_list[1])
    let fullyQualifiedName: String? = nilOrValue(pigeonVar_list[2])
    let type = pigeonVar_list[3] as! PdfFormFieldTypes
    let annotations: Any? = pigeonVar_list[4]
    let isReadOnly: Bool? = nilOrValue(pigeonVar_list[5])
    let isRequired: Bool? = nilOrValue(pigeonVar_list[6])
    let isExported: Bool? = nilOrValue(pigeonVar_list[7])
    let isDirty: Bool? = nilOrValue(pigeonVar_list[8])
    let options: [PdfFormOption?]? = nilOrValue(pigeonVar_list[9])

    return FormFieldData(
      name: name,
      alternativeFieldName: alternativeFieldName,
      fullyQualifiedName: fullyQualifiedName,
      type: type,
      annotations: annotations,
      isReadOnly: isReadOnly,
      isRequired: isRequired,
      isExported: isExported,
      isDirty: isDirty,
      options: options
    )
  }
  func toList() -> [Any?] {
    return [
      name,
      alternativeFieldName,
      fullyQualifiedName,
      type,
      annotations,
      isReadOnly,
      isRequired,
      isExported,
      isDirty,
      options,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PointF {
  var x: Double
  var y: Double


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PointF? {
    let x = pigeonVar_list[0] as! Double
    let y = pigeonVar_list[1] as! Double

    return PointF(
      x: x,
      y: y
    )
  }
  func toList() -> [Any?] {
    return [
      x,
      y,
    ]
  }
}

/// Configuration data for annotation contextual menu
///
/// This class defines how annotation menus should be configured
/// when displayed to users. It supports removing actions, disabling actions,
/// and controlling visual presentation options.
///
/// **Usage Patterns**:
/// - **Static Configuration**: Set once via [NutrientViewController.setAnnotationMenuConfiguration]
///
/// **Platform Compatibility**:
/// - [itemsToRemove]: Supported on Android, iOS, and Web
/// - [itemsToDisable]: Supported on Android, iOS, and Web
/// - [showStylePicker]: Supported on Android and iOS
/// - [groupMarkupItems]: iOS only (ignored on other platforms)
/// - [maxVisibleItems]: Platform-dependent behavior
///
/// Generated class from Pigeon that represents data sent in messages.
struct AnnotationMenuConfigurationData {
  /// List of default annotation menu actions to remove completely from the menu.
  ///
  /// These actions will not appear in the contextual menu at all.
  /// Use this when you want to completely hide certain functionality.
  ///
  /// **Example**: Remove delete action for read-only annotations
  /// ```dart
  /// itemsToRemove: [AnnotationMenuAction.delete]
  /// ```
  var itemsToRemove: [AnnotationMenuAction]
  /// List of default annotation menu actions to disable (show as grayed out).
  ///
  /// These actions will appear in the menu but will be non-interactive.
  /// Use this when you want to show functionality exists but is temporarily unavailable.
  ///
  /// **Example**: Disable copy action for certain annotation types
  /// ```dart
  /// itemsToDisable: [AnnotationMenuAction.copy]
  /// ```
  var itemsToDisable: [AnnotationMenuAction]
  /// Whether to show the platform's default style picker in the annotation menu.
  ///
  /// When true, users can access color, thickness, and other style options
  /// directly from the annotation menu.
  ///
  /// **Platform Behavior**:
  /// - **iOS**: Shows style picker as part of UIMenu
  /// - **Android**: Shows annotation inspector/style picker
  /// - **Web**: Shows color picker and basic style options
  var showStylePicker: Bool
  /// Whether to group markup annotation actions together in the menu.
  ///
  /// When true, related markup actions (highlight, underline, etc.) are
  /// visually grouped in the menu for better organization.
  ///
  /// **Platform Support**: iOS only (ignored on Android and Web)
  var groupMarkupItems: Bool
  /// Maximum number of actions to show directly in the menu before creating overflow.
  ///
  /// When the number of available actions exceeds this limit, the platform
  /// may create a submenu or overflow menu to accommodate additional actions.
  ///
  /// **Platform Behavior**:
  /// - **iOS**: Respects platform UI guidelines for menu length
  /// - **Android**: Limited by toolbar space and screen size
  /// - **Web**: Creates scrollable or paginated menu as needed
  ///
  /// **Note**: If null, the platform default behavior is used.
  var maxVisibleItems: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AnnotationMenuConfigurationData? {
    let itemsToRemove = pigeonVar_list[0] as! [AnnotationMenuAction]
    let itemsToDisable = pigeonVar_list[1] as! [AnnotationMenuAction]
    let showStylePicker = pigeonVar_list[2] as! Bool
    let groupMarkupItems = pigeonVar_list[3] as! Bool
    let maxVisibleItems: Int64? = nilOrValue(pigeonVar_list[4])

    return AnnotationMenuConfigurationData(
      itemsToRemove: itemsToRemove,
      itemsToDisable: itemsToDisable,
      showStylePicker: showStylePicker,
      groupMarkupItems: groupMarkupItems,
      maxVisibleItems: maxVisibleItems
    )
  }
  func toList() -> [Any?] {
    return [
      itemsToRemove,
      itemsToDisable,
      showStylePicker,
      groupMarkupItems,
      maxVisibleItems,
    ]
  }
}

/// Data class for annotation properties that provides type-safe access
/// to annotation attributes while preserving attachments and custom data.
///
/// This class is used with the AnnotationManager API to safely update
/// annotation properties without losing data during the update process.
///
/// **Usage Pattern**:
/// ```dart
/// // Get current properties
/// final properties = await annotationManager.getAnnotationProperties(pageIndex, annotationId);
///
/// // Create modified version
/// final updated = properties?.withColor(Colors.red).withOpacity(0.7);
///
/// // Save changes
/// if (updated != null) {
///   await annotationManager.saveAnnotationProperties(updated);
/// }
/// ```
///
/// **Data Preservation**: Unlike the deprecated `updateAnnotation` method,
/// this approach preserves attachments, custom data, and other properties
/// that are not being explicitly modified.
///
/// Generated class from Pigeon that represents data sent in messages.
struct AnnotationProperties {
  /// Unique identifier for the annotation
  var annotationId: String
  /// Zero-based page index where the annotation is located
  var pageIndex: Int64
  /// Stroke color as ARGB integer (e.g., 0xFFFF0000 for red)
  var strokeColor: Int64? = nil
  /// Fill color as ARGB integer (e.g., 0xFF0000FF for blue)
  var fillColor: Int64? = nil
  /// Opacity value between 0.0 (transparent) and 1.0 (opaque)
  var opacity: Double? = nil
  /// Line width for stroke-based annotations (in points)
  var lineWidth: Double? = nil
  /// List of annotation flags (e.g., ['readOnly', 'print'])
  var flags: [String]? = nil
  /// Custom data associated with the annotation
  /// This preserves any application-specific metadata
  var customData: [String: Any?]? = nil
  /// Text content of the annotation (for text-based annotations)
  var contents: String? = nil
  /// Subject/title of the annotation
  var subject: String? = nil
  /// Creator/author of the annotation
  var creator: String? = nil
  /// Bounding box as [x, y, width, height] in PDF coordinates
  var bbox: [Double]? = nil
  /// Note text associated with the annotation
  var note: String? = nil
  /// Ink lines for ink annotations as [[[x, y, pressure], ...], ...]
  /// Each line is an array of points, each point is [x, y, pressure]
  var inkLines: [[[Double]]]? = nil
  /// Font name for text annotations
  var fontName: String? = nil
  /// Font size for text annotations (in points)
  var fontSize: Double? = nil
  /// Icon name for note annotations (e.g., 'Comment', 'Key', 'Note')
  var iconName: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AnnotationProperties? {
    let annotationId = pigeonVar_list[0] as! String
    let pageIndex = pigeonVar_list[1] as! Int64
    let strokeColor: Int64? = nilOrValue(pigeonVar_list[2])
    let fillColor: Int64? = nilOrValue(pigeonVar_list[3])
    let opacity: Double? = nilOrValue(pigeonVar_list[4])
    let lineWidth: Double? = nilOrValue(pigeonVar_list[5])
    let flags: [String]? = nilOrValue(pigeonVar_list[6])
    let customData: [String: Any?]? = nilOrValue(pigeonVar_list[7])
    let contents: String? = nilOrValue(pigeonVar_list[8])
    let subject: String? = nilOrValue(pigeonVar_list[9])
    let creator: String? = nilOrValue(pigeonVar_list[10])
    let bbox: [Double]? = nilOrValue(pigeonVar_list[11])
    let note: String? = nilOrValue(pigeonVar_list[12])
    let inkLines: [[[Double]]]? = nilOrValue(pigeonVar_list[13])
    let fontName: String? = nilOrValue(pigeonVar_list[14])
    let fontSize: Double? = nilOrValue(pigeonVar_list[15])
    let iconName: String? = nilOrValue(pigeonVar_list[16])

    return AnnotationProperties(
      annotationId: annotationId,
      pageIndex: pageIndex,
      strokeColor: strokeColor,
      fillColor: fillColor,
      opacity: opacity,
      lineWidth: lineWidth,
      flags: flags,
      customData: customData,
      contents: contents,
      subject: subject,
      creator: creator,
      bbox: bbox,
      note: note,
      inkLines: inkLines,
      fontName: fontName,
      fontSize: fontSize,
      iconName: iconName
    )
  }
  func toList() -> [Any?] {
    return [
      annotationId,
      pageIndex,
      strokeColor,
      fillColor,
      opacity,
      lineWidth,
      flags,
      customData,
      contents,
      subject,
      creator,
      bbox,
      note,
      inkLines,
      fontName,
      fontSize,
      iconName,
    ]
  }
}

private class NutrientApiPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AndroidPermissionStatus(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AnnotationType(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AnnotationTool(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AnnotationToolVariant(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AnnotationProcessingMode(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return DocumentPermissions(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PdfVersion(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PdfFormFieldTypes(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return NutrientEvent(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AnnotationMenuAction(rawValue: enumResultAsInt)
      }
      return nil
    case 139:
      return PdfRect.fromList(self.readValue() as! [Any?])
    case 140:
      return PageInfo.fromList(self.readValue() as! [Any?])
    case 141:
      return DocumentSaveOptions.fromList(self.readValue() as! [Any?])
    case 142:
      return PdfFormOption.fromList(self.readValue() as! [Any?])
    case 143:
      return FormFieldData.fromList(self.readValue() as! [Any?])
    case 144:
      return PointF.fromList(self.readValue() as! [Any?])
    case 145:
      return AnnotationMenuConfigurationData.fromList(self.readValue() as! [Any?])
    case 146:
      return AnnotationProperties.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class NutrientApiPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AndroidPermissionStatus {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? AnnotationType {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? AnnotationTool {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? AnnotationToolVariant {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? AnnotationProcessingMode {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? DocumentPermissions {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? PdfVersion {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? PdfFormFieldTypes {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? NutrientEvent {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? AnnotationMenuAction {
      super.writeByte(138)
      super.writeValue(value.rawValue)
    } else if let value = value as? PdfRect {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? PageInfo {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? DocumentSaveOptions {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? PdfFormOption {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? FormFieldData {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? PointF {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? AnnotationMenuConfigurationData {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? AnnotationProperties {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class NutrientApiPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return NutrientApiPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return NutrientApiPigeonCodecWriter(data: data)
  }
}

class NutrientApiPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = NutrientApiPigeonCodec(readerWriter: NutrientApiPigeonCodecReaderWriter())
}


/// The API for interacting with a PDF document.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol NutrientApi {
  func getFrameworkVersion(completion: @escaping (Result<String?, Error>) -> Void)
  func setLicenseKey(licenseKey: String?, completion: @escaping (Result<Void, Error>) -> Void)
  func setLicenseKeys(androidLicenseKey: String?, iOSLicenseKey: String?, webLicenseKey: String?, completion: @escaping (Result<Void, Error>) -> Void)
  func present(document: String, configuration: [String: Any]?, completion: @escaping (Result<Bool?, Error>) -> Void)
  func presentInstant(serverUrl: String, jwt: String, configuration: [String: Any]?, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setFormFieldValue(value: String, fullyQualifiedName: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func getFormFieldValue(fullyQualifiedName: String, completion: @escaping (Result<String?, Error>) -> Void)
  func applyInstantJson(annotationsJson: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func exportInstantJson(completion: @escaping (Result<String?, Error>) -> Void)
  func addAnnotation(annotation: String, attachment: String?, completion: @escaping (Result<Bool?, Error>) -> Void)
  func removeAnnotation(annotation: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func getAnnotations(pageIndex: Int64, type: String, completion: @escaping (Result<Any?, Error>) -> Void)
  func getAllUnsavedAnnotations(completion: @escaping (Result<Any?, Error>) -> Void)
  func updateAnnotation(annotation: String, completion: @escaping (Result<Void, Error>) -> Void)
  func processAnnotations(type: AnnotationType, processingMode: AnnotationProcessingMode, destinationPath: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func importXfdf(xfdfString: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func exportXfdf(xfdfPath: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func save(completion: @escaping (Result<Bool?, Error>) -> Void)
  func setDelayForSyncingLocalChanges(delay: Double, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setListenToServerChanges(listen: Bool, completion: @escaping (Result<Bool?, Error>) -> Void)
  func syncAnnotations(completion: @escaping (Result<Bool?, Error>) -> Void)
  func checkAndroidWriteExternalStoragePermission(completion: @escaping (Result<Bool?, Error>) -> Void)
  func requestAndroidWriteExternalStoragePermission(completion: @escaping (Result<AndroidPermissionStatus, Error>) -> Void)
  func openAndroidSettings(completion: @escaping (Result<Void, Error>) -> Void)
  func setAnnotationPresetConfigurations(configurations: [String: Any?], completion: @escaping (Result<Bool?, Error>) -> Void)
  func getTemporaryDirectory(completion: @escaping (Result<String, Error>) -> Void)
  func setAuthorName(name: String, completion: @escaping (Result<Void, Error>) -> Void)
  func getAuthorName(completion: @escaping (Result<String, Error>) -> Void)
  /// Generate PDF from Images, Template, and Patterns.
  /// [pages]: [NewPage]s to be added to the PDF.
  /// [outputPath]: The path to the output file.
  /// Returns the path to the generated PDF path or null if the input is invalid or if the PDF generation fails.
  func generatePdf(pages: [[String: Any]], outputPath: String, completion: @escaping (Result<String?, Error>) -> Void)
  /// Generates a PDF from HTML string.
  ///
  /// [html]: The HTML string to be converted to PDF.
  /// [outPutFile]: The path to the output file.
  /// Returns the path to the generated PDF file or null if the input is invalid or if the PDF generation fails.
  func generatePdfFromHtmlString(html: String, outPutFile: String, options: [String: Any]?, completion: @escaping (Result<String?, Error>) -> Void)
  func generatePdfFromHtmlUri(htmlUri: String, outPutFile: String, options: [String: Any]?, completion: @escaping (Result<String?, Error>) -> Void)
  /// Configure Nutrient Analytics events.
  func enableAnalyticsEvents(enable: Bool) throws
  /// Sets the annotation menu configuration for the global presenter.
  /// This configuration applies to all annotation menus in presented documents.
  ///
  /// @param configuration The annotation menu configuration to apply.
  /// @return True if the configuration was set successfully, false otherwise.
  func setAnnotationMenuConfiguration(configuration: AnnotationMenuConfigurationData, completion: @escaping (Result<Bool?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class NutrientApiSetup {
  static var codec: FlutterStandardMessageCodec { NutrientApiPigeonCodec.shared }
  /// Sets up an instance of `NutrientApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: NutrientApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getFrameworkVersionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.getFrameworkVersion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFrameworkVersionChannel.setMessageHandler { _, reply in
        api.getFrameworkVersion { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFrameworkVersionChannel.setMessageHandler(nil)
    }
    let setLicenseKeyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setLicenseKey\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLicenseKeyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let licenseKeyArg: String? = nilOrValue(args[0])
        api.setLicenseKey(licenseKey: licenseKeyArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setLicenseKeyChannel.setMessageHandler(nil)
    }
    let setLicenseKeysChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setLicenseKeys\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLicenseKeysChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let androidLicenseKeyArg: String? = nilOrValue(args[0])
        let iOSLicenseKeyArg: String? = nilOrValue(args[1])
        let webLicenseKeyArg: String? = nilOrValue(args[2])
        api.setLicenseKeys(androidLicenseKey: androidLicenseKeyArg, iOSLicenseKey: iOSLicenseKeyArg, webLicenseKey: webLicenseKeyArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setLicenseKeysChannel.setMessageHandler(nil)
    }
    let presentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.present\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      presentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let documentArg = args[0] as! String
        let configurationArg: [String: Any]? = nilOrValue(args[1])
        api.present(document: documentArg, configuration: configurationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      presentChannel.setMessageHandler(nil)
    }
    let presentInstantChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.presentInstant\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      presentInstantChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let serverUrlArg = args[0] as! String
        let jwtArg = args[1] as! String
        let configurationArg: [String: Any]? = nilOrValue(args[2])
        api.presentInstant(serverUrl: serverUrlArg, jwt: jwtArg, configuration: configurationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      presentInstantChannel.setMessageHandler(nil)
    }
    let setFormFieldValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setFormFieldValue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFormFieldValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! String
        let fullyQualifiedNameArg = args[1] as! String
        api.setFormFieldValue(value: valueArg, fullyQualifiedName: fullyQualifiedNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFormFieldValueChannel.setMessageHandler(nil)
    }
    let getFormFieldValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.getFormFieldValue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFormFieldValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fullyQualifiedNameArg = args[0] as! String
        api.getFormFieldValue(fullyQualifiedName: fullyQualifiedNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFormFieldValueChannel.setMessageHandler(nil)
    }
    let applyInstantJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.applyInstantJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      applyInstantJsonChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationsJsonArg = args[0] as! String
        api.applyInstantJson(annotationsJson: annotationsJsonArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      applyInstantJsonChannel.setMessageHandler(nil)
    }
    let exportInstantJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.exportInstantJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportInstantJsonChannel.setMessageHandler { _, reply in
        api.exportInstantJson { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportInstantJsonChannel.setMessageHandler(nil)
    }
    let addAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.addAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationArg = args[0] as! String
        let attachmentArg: String? = nilOrValue(args[1])
        api.addAnnotation(annotation: annotationArg, attachment: attachmentArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addAnnotationChannel.setMessageHandler(nil)
    }
    let removeAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.removeAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationArg = args[0] as! String
        api.removeAnnotation(annotation: annotationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeAnnotationChannel.setMessageHandler(nil)
    }
    let getAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.getAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAnnotationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        let typeArg = args[1] as! String
        api.getAnnotations(pageIndex: pageIndexArg, type: typeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAnnotationsChannel.setMessageHandler(nil)
    }
    let getAllUnsavedAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.getAllUnsavedAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAllUnsavedAnnotationsChannel.setMessageHandler { _, reply in
        api.getAllUnsavedAnnotations { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAllUnsavedAnnotationsChannel.setMessageHandler(nil)
    }
    let updateAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.updateAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationArg = args[0] as! String
        api.updateAnnotation(annotation: annotationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateAnnotationChannel.setMessageHandler(nil)
    }
    let processAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.processAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      processAnnotationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let typeArg = args[0] as! AnnotationType
        let processingModeArg = args[1] as! AnnotationProcessingMode
        let destinationPathArg = args[2] as! String
        api.processAnnotations(type: typeArg, processingMode: processingModeArg, destinationPath: destinationPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      processAnnotationsChannel.setMessageHandler(nil)
    }
    let importXfdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.importXfdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      importXfdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfStringArg = args[0] as! String
        api.importXfdf(xfdfString: xfdfStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      importXfdfChannel.setMessageHandler(nil)
    }
    let exportXfdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.exportXfdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportXfdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfPathArg = args[0] as! String
        api.exportXfdf(xfdfPath: xfdfPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportXfdfChannel.setMessageHandler(nil)
    }
    let saveChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.save\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      saveChannel.setMessageHandler { _, reply in
        api.save { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      saveChannel.setMessageHandler(nil)
    }
    let setDelayForSyncingLocalChangesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setDelayForSyncingLocalChanges\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setDelayForSyncingLocalChangesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let delayArg = args[0] as! Double
        api.setDelayForSyncingLocalChanges(delay: delayArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setDelayForSyncingLocalChangesChannel.setMessageHandler(nil)
    }
    let setListenToServerChangesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setListenToServerChanges\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setListenToServerChangesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let listenArg = args[0] as! Bool
        api.setListenToServerChanges(listen: listenArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setListenToServerChangesChannel.setMessageHandler(nil)
    }
    let syncAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.syncAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      syncAnnotationsChannel.setMessageHandler { _, reply in
        api.syncAnnotations { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      syncAnnotationsChannel.setMessageHandler(nil)
    }
    let checkAndroidWriteExternalStoragePermissionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.checkAndroidWriteExternalStoragePermission\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      checkAndroidWriteExternalStoragePermissionChannel.setMessageHandler { _, reply in
        api.checkAndroidWriteExternalStoragePermission { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      checkAndroidWriteExternalStoragePermissionChannel.setMessageHandler(nil)
    }
    let requestAndroidWriteExternalStoragePermissionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.requestAndroidWriteExternalStoragePermission\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      requestAndroidWriteExternalStoragePermissionChannel.setMessageHandler { _, reply in
        api.requestAndroidWriteExternalStoragePermission { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      requestAndroidWriteExternalStoragePermissionChannel.setMessageHandler(nil)
    }
    let openAndroidSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.openAndroidSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      openAndroidSettingsChannel.setMessageHandler { _, reply in
        api.openAndroidSettings { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      openAndroidSettingsChannel.setMessageHandler(nil)
    }
    let setAnnotationPresetConfigurationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setAnnotationPresetConfigurations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAnnotationPresetConfigurationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let configurationsArg = args[0] as! [String: Any?]
        api.setAnnotationPresetConfigurations(configurations: configurationsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setAnnotationPresetConfigurationsChannel.setMessageHandler(nil)
    }
    let getTemporaryDirectoryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.getTemporaryDirectory\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTemporaryDirectoryChannel.setMessageHandler { _, reply in
        api.getTemporaryDirectory { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTemporaryDirectoryChannel.setMessageHandler(nil)
    }
    let setAuthorNameChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setAuthorName\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAuthorNameChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let nameArg = args[0] as! String
        api.setAuthorName(name: nameArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setAuthorNameChannel.setMessageHandler(nil)
    }
    let getAuthorNameChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.getAuthorName\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAuthorNameChannel.setMessageHandler { _, reply in
        api.getAuthorName { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAuthorNameChannel.setMessageHandler(nil)
    }
    /// Generate PDF from Images, Template, and Patterns.
    /// [pages]: [NewPage]s to be added to the PDF.
    /// [outputPath]: The path to the output file.
    /// Returns the path to the generated PDF path or null if the input is invalid or if the PDF generation fails.
    let generatePdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.generatePdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      generatePdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pagesArg = args[0] as! [[String: Any]]
        let outputPathArg = args[1] as! String
        api.generatePdf(pages: pagesArg, outputPath: outputPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      generatePdfChannel.setMessageHandler(nil)
    }
    /// Generates a PDF from HTML string.
    ///
    /// [html]: The HTML string to be converted to PDF.
    /// [outPutFile]: The path to the output file.
    /// Returns the path to the generated PDF file or null if the input is invalid or if the PDF generation fails.
    let generatePdfFromHtmlStringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.generatePdfFromHtmlString\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      generatePdfFromHtmlStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let htmlArg = args[0] as! String
        let outPutFileArg = args[1] as! String
        let optionsArg: [String: Any]? = nilOrValue(args[2])
        api.generatePdfFromHtmlString(html: htmlArg, outPutFile: outPutFileArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      generatePdfFromHtmlStringChannel.setMessageHandler(nil)
    }
    let generatePdfFromHtmlUriChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.generatePdfFromHtmlUri\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      generatePdfFromHtmlUriChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let htmlUriArg = args[0] as! String
        let outPutFileArg = args[1] as! String
        let optionsArg: [String: Any]? = nilOrValue(args[2])
        api.generatePdfFromHtmlUri(htmlUri: htmlUriArg, outPutFile: outPutFileArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      generatePdfFromHtmlUriChannel.setMessageHandler(nil)
    }
    /// Configure Nutrient Analytics events.
    let enableAnalyticsEventsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.enableAnalyticsEvents\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enableAnalyticsEventsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let enableArg = args[0] as! Bool
        do {
          try api.enableAnalyticsEvents(enable: enableArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      enableAnalyticsEventsChannel.setMessageHandler(nil)
    }
    /// Sets the annotation menu configuration for the global presenter.
    /// This configuration applies to all annotation menus in presented documents.
    ///
    /// @param configuration The annotation menu configuration to apply.
    /// @return True if the configuration was set successfully, false otherwise.
    let setAnnotationMenuConfigurationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientApi.setAnnotationMenuConfiguration\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAnnotationMenuConfigurationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let configurationArg = args[0] as! AnnotationMenuConfigurationData
        api.setAnnotationMenuConfiguration(configuration: configurationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setAnnotationMenuConfigurationChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol NutrientApiCallbacksProtocol {
  /// onPAuse callback for FlutterPdfActivity
  func onPdfActivityOnPause(completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  func onPdfFragmentAdded(completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  func onDocumentLoaded(documentId documentIdArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  /// ViewControllerWillDismiss callback for PDFViewController
  func onPdfViewControllerWillDismiss(completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  /// ViewControllerDidDismiss callback for PDFViewController
  func onPdfViewControllerDidDismiss(completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  /// Called when instant synchronization starts.
  func onInstantSyncStarted(documentId documentIdArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  /// Called when instant synchronization ends.
  func onInstantSyncFinished(documentId documentIdArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  /// Called when instant synchronization fails.
  func onInstantSyncFailed(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  /// Called when instant authentication is done.
  func onInstantAuthenticationFinished(documentId documentIdArg: String, validJWT validJWTArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  /// Called when instant authentication fails.
  func onInstantAuthenticationFailed(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  /// Only available on iOS.
  /// Called when instant document download is done.
  func onInstantDownloadFinished(documentId documentIdArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  /// Only available on iOS.
  /// Called when instant document download fails.
  func onInstantDownloadFailed(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
}
class NutrientApiCallbacks: NutrientApiCallbacksProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: NutrientApiPigeonCodec {
    return NutrientApiPigeonCodec.shared
  }
  /// onPAuse callback for FlutterPdfActivity
  func onPdfActivityOnPause(completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onPdfActivityOnPause\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onPdfFragmentAdded(completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onPdfFragmentAdded\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onDocumentLoaded(documentId documentIdArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onDocumentLoaded\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// ViewControllerWillDismiss callback for PDFViewController
  func onPdfViewControllerWillDismiss(completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onPdfViewControllerWillDismiss\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// ViewControllerDidDismiss callback for PDFViewController
  func onPdfViewControllerDidDismiss(completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onPdfViewControllerDidDismiss\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Called when instant synchronization starts.
  func onInstantSyncStarted(documentId documentIdArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncStarted\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Called when instant synchronization ends.
  func onInstantSyncFinished(documentId documentIdArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncFinished\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Called when instant synchronization fails.
  func onInstantSyncFailed(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantSyncFailed\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Called when instant authentication is done.
  func onInstantAuthenticationFinished(documentId documentIdArg: String, validJWT validJWTArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantAuthenticationFinished\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, validJWTArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Called when instant authentication fails.
  func onInstantAuthenticationFailed(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantAuthenticationFailed\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Only available on iOS.
  /// Called when instant document download is done.
  func onInstantDownloadFinished(documentId documentIdArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantDownloadFinished\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Only available on iOS.
  /// Called when instant document download fails.
  func onInstantDownloadFailed(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientApiCallbacks.onInstantDownloadFailed\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol NutrientViewControllerApi {
  /// Sets the value of a form field by specifying its fully qualified field name.
  /// This method is deprecated. Use [PdfDocument.setFormFieldValue] instead.
  func setFormFieldValue(value: String, fullyQualifiedName: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Gets the form field value by specifying its fully qualified name.
  func getFormFieldValue(fullyQualifiedName: String, completion: @escaping (Result<String?, Error>) -> Void)
  /// Applies Instant document JSON to the presented document.
  func applyInstantJson(annotationsJson: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Exports Instant document JSON from the presented document.
  func exportInstantJson(completion: @escaping (Result<String?, Error>) -> Void)
  /// Adds the given annotation to the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  func addAnnotation(annotation: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Removes the given annotation from the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  func removeAnnotation(annotation: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Returns a list of JSON dictionaries for all the annotations of the given `type` on the given `pageIndex`.
  func getAnnotations(pageIndex: Int64, type: String, completion: @escaping (Result<Any, Error>) -> Void)
  /// Returns a list of JSON dictionaries for all the unsaved annotations in the presented document.
  func getAllUnsavedAnnotations(completion: @escaping (Result<Any, Error>) -> Void)
  /// Processes annotations of the given type with the provided processing
  /// mode and stores the PDF at the given destination path.
  func processAnnotations(type: AnnotationType, processingMode: AnnotationProcessingMode, destinationPath: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Imports annotations from the XFDF file at the given path.
  func importXfdf(xfdfString: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Exports annotations to the XFDF file at the given path.
  func exportXfdf(xfdfPath: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Saves the document back to its original location if it has been changed.
  /// If there were no changes to the document, the document file will not be modified.
  func save(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Sets the annotation preset configurations for the given annotation tools.
  /// @param configurations A map of annotation tools and their corresponding configurations.
  /// @param modifyAssociatedAnnotations Whether to modify the annotations associated with the old configuration. Only used for Android.
  /// @return True if the configurations were set successfully, false otherwise.
  func setAnnotationConfigurations(configurations: [String: [String: Any]], completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Gets the visible rect of the given page.
  /// pageIndex The index of the page. This is a zero-based index.
  /// Returns a [Future] that completes with the visible rect of the given page.
  func getVisibleRect(pageIndex: Int64, completion: @escaping (Result<PdfRect, Error>) -> Void)
  /// Zooms to the given rect on the given page.
  /// pageIndex The index of the page. This is a zero-based index.
  /// rect The rect to zoom to.
  /// Returns a [Future] that completes when the zoom operation is done.
  func zoomToRect(pageIndex: Int64, rect: PdfRect, animated: Bool?, duration: Double?, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Gets the zoom scale of the given page.
  /// pageIndex The index of the page. This is a zero-based index.
  /// Returns a [Future] that completes with the zoom scale of the given page.
  func getZoomScale(pageIndex: Int64, completion: @escaping (Result<Double, Error>) -> Void)
  func addEventListener(event: NutrientEvent) throws
  func removeEventListener(event: NutrientEvent) throws
  /// Enters annotation creation mode.
  ///
  /// If [annotationTool] is provided, that specific tool will be activated.
  /// If no tool is provided, the default annotation tool will be used.
  ///
  /// Returns a [Future] that completes with a boolean indicating whether
  /// entering annotation creation mode was successful.
  func enterAnnotationCreationMode(annotationTool: AnnotationTool?, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Exits annotation creation mode.
  ///
  /// Returns a [Future] that completes with a boolean indicating whether
  /// exiting annotation creation mode was successful.
  func exitAnnotationCreationMode(completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Sets the annotation menu configuration for the current view controller.
  /// This configuration applies only to annotation menus in the current document view.
  ///
  /// @param configuration The annotation menu configuration to apply.
  /// @return True if the configuration was set successfully, false otherwise.
  func setAnnotationMenuConfiguration(configuration: AnnotationMenuConfigurationData, completion: @escaping (Result<Bool?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class NutrientViewControllerApiSetup {
  static var codec: FlutterStandardMessageCodec { NutrientApiPigeonCodec.shared }
  /// Sets up an instance of `NutrientViewControllerApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: NutrientViewControllerApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Sets the value of a form field by specifying its fully qualified field name.
    /// This method is deprecated. Use [PdfDocument.setFormFieldValue] instead.
    let setFormFieldValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.setFormFieldValue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFormFieldValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! String
        let fullyQualifiedNameArg = args[1] as! String
        api.setFormFieldValue(value: valueArg, fullyQualifiedName: fullyQualifiedNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFormFieldValueChannel.setMessageHandler(nil)
    }
    /// Gets the form field value by specifying its fully qualified name.
    let getFormFieldValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getFormFieldValue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFormFieldValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fullyQualifiedNameArg = args[0] as! String
        api.getFormFieldValue(fullyQualifiedName: fullyQualifiedNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFormFieldValueChannel.setMessageHandler(nil)
    }
    /// Applies Instant document JSON to the presented document.
    let applyInstantJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.applyInstantJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      applyInstantJsonChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationsJsonArg = args[0] as! String
        api.applyInstantJson(annotationsJson: annotationsJsonArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      applyInstantJsonChannel.setMessageHandler(nil)
    }
    /// Exports Instant document JSON from the presented document.
    let exportInstantJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.exportInstantJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportInstantJsonChannel.setMessageHandler { _, reply in
        api.exportInstantJson { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportInstantJsonChannel.setMessageHandler(nil)
    }
    /// Adds the given annotation to the presented document.
    /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
    let addAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.addAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationArg = args[0] as! String
        api.addAnnotation(annotation: annotationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addAnnotationChannel.setMessageHandler(nil)
    }
    /// Removes the given annotation from the presented document.
    /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
    let removeAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.removeAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationArg = args[0] as! String
        api.removeAnnotation(annotation: annotationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeAnnotationChannel.setMessageHandler(nil)
    }
    /// Returns a list of JSON dictionaries for all the annotations of the given `type` on the given `pageIndex`.
    let getAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAnnotationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        let typeArg = args[1] as! String
        api.getAnnotations(pageIndex: pageIndexArg, type: typeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAnnotationsChannel.setMessageHandler(nil)
    }
    /// Returns a list of JSON dictionaries for all the unsaved annotations in the presented document.
    let getAllUnsavedAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getAllUnsavedAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAllUnsavedAnnotationsChannel.setMessageHandler { _, reply in
        api.getAllUnsavedAnnotations { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAllUnsavedAnnotationsChannel.setMessageHandler(nil)
    }
    /// Processes annotations of the given type with the provided processing
    /// mode and stores the PDF at the given destination path.
    let processAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.processAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      processAnnotationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let typeArg = args[0] as! AnnotationType
        let processingModeArg = args[1] as! AnnotationProcessingMode
        let destinationPathArg = args[2] as! String
        api.processAnnotations(type: typeArg, processingMode: processingModeArg, destinationPath: destinationPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      processAnnotationsChannel.setMessageHandler(nil)
    }
    /// Imports annotations from the XFDF file at the given path.
    let importXfdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.importXfdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      importXfdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfStringArg = args[0] as! String
        api.importXfdf(xfdfString: xfdfStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      importXfdfChannel.setMessageHandler(nil)
    }
    /// Exports annotations to the XFDF file at the given path.
    let exportXfdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.exportXfdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportXfdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfPathArg = args[0] as! String
        api.exportXfdf(xfdfPath: xfdfPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportXfdfChannel.setMessageHandler(nil)
    }
    /// Saves the document back to its original location if it has been changed.
    /// If there were no changes to the document, the document file will not be modified.
    let saveChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.save\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      saveChannel.setMessageHandler { _, reply in
        api.save { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      saveChannel.setMessageHandler(nil)
    }
    /// Sets the annotation preset configurations for the given annotation tools.
    /// @param configurations A map of annotation tools and their corresponding configurations.
    /// @param modifyAssociatedAnnotations Whether to modify the annotations associated with the old configuration. Only used for Android.
    /// @return True if the configurations were set successfully, false otherwise.
    let setAnnotationConfigurationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.setAnnotationConfigurations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAnnotationConfigurationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let configurationsArg = args[0] as! [String: [String: Any]]
        api.setAnnotationConfigurations(configurations: configurationsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setAnnotationConfigurationsChannel.setMessageHandler(nil)
    }
    /// Gets the visible rect of the given page.
    /// pageIndex The index of the page. This is a zero-based index.
    /// Returns a [Future] that completes with the visible rect of the given page.
    let getVisibleRectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getVisibleRect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVisibleRectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        api.getVisibleRect(pageIndex: pageIndexArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getVisibleRectChannel.setMessageHandler(nil)
    }
    /// Zooms to the given rect on the given page.
    /// pageIndex The index of the page. This is a zero-based index.
    /// rect The rect to zoom to.
    /// Returns a [Future] that completes when the zoom operation is done.
    let zoomToRectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.zoomToRect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      zoomToRectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        let rectArg = args[1] as! PdfRect
        let animatedArg: Bool? = nilOrValue(args[2])
        let durationArg: Double? = nilOrValue(args[3])
        api.zoomToRect(pageIndex: pageIndexArg, rect: rectArg, animated: animatedArg, duration: durationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      zoomToRectChannel.setMessageHandler(nil)
    }
    /// Gets the zoom scale of the given page.
    /// pageIndex The index of the page. This is a zero-based index.
    /// Returns a [Future] that completes with the zoom scale of the given page.
    let getZoomScaleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.getZoomScale\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getZoomScaleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        api.getZoomScale(pageIndex: pageIndexArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getZoomScaleChannel.setMessageHandler(nil)
    }
    let addEventListenerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.addEventListener\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addEventListenerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let eventArg = args[0] as! NutrientEvent
        do {
          try api.addEventListener(event: eventArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addEventListenerChannel.setMessageHandler(nil)
    }
    let removeEventListenerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.removeEventListener\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeEventListenerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let eventArg = args[0] as! NutrientEvent
        do {
          try api.removeEventListener(event: eventArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeEventListenerChannel.setMessageHandler(nil)
    }
    /// Enters annotation creation mode.
    ///
    /// If [annotationTool] is provided, that specific tool will be activated.
    /// If no tool is provided, the default annotation tool will be used.
    ///
    /// Returns a [Future] that completes with a boolean indicating whether
    /// entering annotation creation mode was successful.
    let enterAnnotationCreationModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.enterAnnotationCreationMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enterAnnotationCreationModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationToolArg: AnnotationTool? = nilOrValue(args[0])
        api.enterAnnotationCreationMode(annotationTool: annotationToolArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      enterAnnotationCreationModeChannel.setMessageHandler(nil)
    }
    /// Exits annotation creation mode.
    ///
    /// Returns a [Future] that completes with a boolean indicating whether
    /// exiting annotation creation mode was successful.
    let exitAnnotationCreationModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.exitAnnotationCreationMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exitAnnotationCreationModeChannel.setMessageHandler { _, reply in
        api.exitAnnotationCreationMode { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exitAnnotationCreationModeChannel.setMessageHandler(nil)
    }
    /// Sets the annotation menu configuration for the current view controller.
    /// This configuration applies only to annotation menus in the current document view.
    ///
    /// @param configuration The annotation menu configuration to apply.
    /// @return True if the configuration was set successfully, false otherwise.
    let setAnnotationMenuConfigurationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.NutrientViewControllerApi.setAnnotationMenuConfiguration\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAnnotationMenuConfigurationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let configurationArg = args[0] as! AnnotationMenuConfigurationData
        api.setAnnotationMenuConfiguration(configuration: configurationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setAnnotationMenuConfigurationChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PdfDocumentApi {
  /// Returns the page info for the given page index.
  /// pageIndex The index of the page. This is a zero-based index.
  func getPageInfo(pageIndex: Int64, completion: @escaping (Result<PageInfo, Error>) -> Void)
  /// Exports the document as a PDF.
  /// options:[DocumentSaveOptions] The options to use when exporting the document.
  /// Returns a [Uint8List] containing the exported PDF data.
  func exportPdf(options: DocumentSaveOptions?, completion: @escaping (Result<FlutterStandardTypedData, Error>) -> Void)
  func getFormField(fieldName: String, completion: @escaping (Result<[String: Any?], Error>) -> Void)
  /// Returns a list of all form fields in the document.
  func getFormFields(completion: @escaping (Result<[[String: Any?]], Error>) -> Void)
  /// Sets the value of a form field by specifying its fully qualified field name.
  func setFormFieldValue(value: String, fullyQualifiedName: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Gets the form field value by specifying its fully qualified name.
  func getFormFieldValue(fullyQualifiedName: String, completion: @escaping (Result<String?, Error>) -> Void)
  /// Applies Instant document JSON to the presented document.
  func applyInstantJson(annotationsJson: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Exports Instant document JSON from the presented document.
  func exportInstantJson(completion: @escaping (Result<String?, Error>) -> Void)
  /// Adds the given annotation to the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  func addAnnotation(jsonAnnotation: String, attachment: Any?, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Updates the given annotation in the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  ///
  /// @deprecated Use setAnnotationProperties() or specific property setters instead.
  /// This method has a critical bug that causes data loss for annotations with attachments.
  /// It will be removed in version 7.0.0.
  ///
  /// Migration:
  /// - For single property updates: Use specific setters like setAnnotationColor()
  /// - For multiple property updates: Use setAnnotationProperties()
  func updateAnnotation(jsonAnnotation: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Removes the given annotation from the presented document.
  /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
  func removeAnnotation(jsonAnnotation: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Returns a list of JSON dictionaries for all the annotations of the given `type` on the given `pageIndex`.
  func getAnnotations(pageIndex: Int64, type: String, completion: @escaping (Result<Any, Error>) -> Void)
  /// Returns a list of JSON dictionaries for all the unsaved annotations in the presented document.
  func getAllUnsavedAnnotations(completion: @escaping (Result<Any, Error>) -> Void)
  /// Imports annotations from the XFDF file at the given path.
  func importXfdf(xfdfString: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Exports annotations to the XFDF file at the given path.
  func exportXfdf(xfdfPath: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Saves the document back to its original location if it has been changed.
  /// If there were no changes to the document, the document file will not be modified.
  func save(outputPath: String?, options: DocumentSaveOptions?, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Get the total number of pages in the document.
  func getPageCount(completion: @escaping (Result<Int64, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PdfDocumentApiSetup {
  static var codec: FlutterStandardMessageCodec { NutrientApiPigeonCodec.shared }
  /// Sets up an instance of `PdfDocumentApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PdfDocumentApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Returns the page info for the given page index.
    /// pageIndex The index of the page. This is a zero-based index.
    let getPageInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getPageInfo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPageInfoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        api.getPageInfo(pageIndex: pageIndexArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getPageInfoChannel.setMessageHandler(nil)
    }
    /// Exports the document as a PDF.
    /// options:[DocumentSaveOptions] The options to use when exporting the document.
    /// Returns a [Uint8List] containing the exported PDF data.
    let exportPdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.exportPdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportPdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg: DocumentSaveOptions? = nilOrValue(args[0])
        api.exportPdf(options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportPdfChannel.setMessageHandler(nil)
    }
    let getFormFieldChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getFormField\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFormFieldChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fieldNameArg = args[0] as! String
        api.getFormField(fieldName: fieldNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFormFieldChannel.setMessageHandler(nil)
    }
    /// Returns a list of all form fields in the document.
    let getFormFieldsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getFormFields\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFormFieldsChannel.setMessageHandler { _, reply in
        api.getFormFields { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFormFieldsChannel.setMessageHandler(nil)
    }
    /// Sets the value of a form field by specifying its fully qualified field name.
    let setFormFieldValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.setFormFieldValue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFormFieldValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let valueArg = args[0] as! String
        let fullyQualifiedNameArg = args[1] as! String
        api.setFormFieldValue(value: valueArg, fullyQualifiedName: fullyQualifiedNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFormFieldValueChannel.setMessageHandler(nil)
    }
    /// Gets the form field value by specifying its fully qualified name.
    let getFormFieldValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getFormFieldValue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFormFieldValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fullyQualifiedNameArg = args[0] as! String
        api.getFormFieldValue(fullyQualifiedName: fullyQualifiedNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFormFieldValueChannel.setMessageHandler(nil)
    }
    /// Applies Instant document JSON to the presented document.
    let applyInstantJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.applyInstantJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      applyInstantJsonChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotationsJsonArg = args[0] as! String
        api.applyInstantJson(annotationsJson: annotationsJsonArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      applyInstantJsonChannel.setMessageHandler(nil)
    }
    /// Exports Instant document JSON from the presented document.
    let exportInstantJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.exportInstantJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportInstantJsonChannel.setMessageHandler { _, reply in
        api.exportInstantJson { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportInstantJsonChannel.setMessageHandler(nil)
    }
    /// Adds the given annotation to the presented document.
    /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
    let addAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.addAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let jsonAnnotationArg = args[0] as! String
        let attachmentArg: Any? = args[1]
        api.addAnnotation(jsonAnnotation: jsonAnnotationArg, attachment: attachmentArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addAnnotationChannel.setMessageHandler(nil)
    }
    /// Updates the given annotation in the presented document.
    /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
    ///
    /// @deprecated Use setAnnotationProperties() or specific property setters instead.
    /// This method has a critical bug that causes data loss for annotations with attachments.
    /// It will be removed in version 7.0.0.
    ///
    /// Migration:
    /// - For single property updates: Use specific setters like setAnnotationColor()
    /// - For multiple property updates: Use setAnnotationProperties()
    let updateAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.updateAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let jsonAnnotationArg = args[0] as! String
        api.updateAnnotation(jsonAnnotation: jsonAnnotationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateAnnotationChannel.setMessageHandler(nil)
    }
    /// Removes the given annotation from the presented document.
    /// `jsonAnnotation` can either be a JSON string or a valid JSON Dictionary (iOS) / HashMap (Android).
    let removeAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.removeAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let jsonAnnotationArg = args[0] as! String
        api.removeAnnotation(jsonAnnotation: jsonAnnotationArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeAnnotationChannel.setMessageHandler(nil)
    }
    /// Returns a list of JSON dictionaries for all the annotations of the given `type` on the given `pageIndex`.
    let getAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAnnotationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        let typeArg = args[1] as! String
        api.getAnnotations(pageIndex: pageIndexArg, type: typeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAnnotationsChannel.setMessageHandler(nil)
    }
    /// Returns a list of JSON dictionaries for all the unsaved annotations in the presented document.
    let getAllUnsavedAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getAllUnsavedAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAllUnsavedAnnotationsChannel.setMessageHandler { _, reply in
        api.getAllUnsavedAnnotations { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAllUnsavedAnnotationsChannel.setMessageHandler(nil)
    }
    /// Imports annotations from the XFDF file at the given path.
    let importXfdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.importXfdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      importXfdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfStringArg = args[0] as! String
        api.importXfdf(xfdfString: xfdfStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      importXfdfChannel.setMessageHandler(nil)
    }
    /// Exports annotations to the XFDF file at the given path.
    let exportXfdfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.exportXfdf\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportXfdfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfPathArg = args[0] as! String
        api.exportXfdf(xfdfPath: xfdfPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportXfdfChannel.setMessageHandler(nil)
    }
    /// Saves the document back to its original location if it has been changed.
    /// If there were no changes to the document, the document file will not be modified.
    let saveChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.save\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      saveChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let outputPathArg: String? = nilOrValue(args[0])
        let optionsArg: DocumentSaveOptions? = nilOrValue(args[1])
        api.save(outputPath: outputPathArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      saveChannel.setMessageHandler(nil)
    }
    /// Get the total number of pages in the document.
    let getPageCountChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.PdfDocumentApi.getPageCount\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPageCountChannel.setMessageHandler { _, reply in
        api.getPageCount { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getPageCountChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol NutrientViewCallbacksProtocol {
  func onDocumentLoaded(documentId documentIdArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  func onDocumentError(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  func onPageChanged(documentId documentIdArg: String, pageIndex pageIndexArg: Int64, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  func onPageClick(documentId documentIdArg: String, pageIndex pageIndexArg: Int64, point pointArg: PointF?, annotation annotationArg: Any?, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
  func onDocumentSaved(documentId documentIdArg: String, path pathArg: String?, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
}
class NutrientViewCallbacks: NutrientViewCallbacksProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: NutrientApiPigeonCodec {
    return NutrientApiPigeonCodec.shared
  }
  func onDocumentLoaded(documentId documentIdArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentLoaded\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onDocumentError(documentId documentIdArg: String, error errorArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentError\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onPageChanged(documentId documentIdArg: String, pageIndex pageIndexArg: Int64, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onPageChanged\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, pageIndexArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onPageClick(documentId documentIdArg: String, pageIndex pageIndexArg: Int64, point pointArg: PointF?, annotation annotationArg: Any?, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onPageClick\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, pageIndexArg, pointArg, annotationArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onDocumentSaved(documentId documentIdArg: String, path pathArg: String?, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientViewCallbacks.onDocumentSaved\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([documentIdArg, pathArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol NutrientEventsCallbacksProtocol {
  func onEvent(event eventArg: NutrientEvent, data dataArg: Any?, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
}
class NutrientEventsCallbacks: NutrientEventsCallbacksProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: NutrientApiPigeonCodec {
    return NutrientApiPigeonCodec.shared
  }
  func onEvent(event eventArg: NutrientEvent, data dataArg: Any?, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.NutrientEventsCallbacks.onEvent\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([eventArg, dataArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol AnalyticsEventsCallbackProtocol {
  func onEvent(event eventArg: String, attributes attributesArg: [String: Any?]?, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
}
class AnalyticsEventsCallback: AnalyticsEventsCallbackProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: NutrientApiPigeonCodec {
    return NutrientApiPigeonCodec.shared
  }
  func onEvent(event eventArg: String, attributes attributesArg: [String: Any?]?, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.AnalyticsEventsCallback.onEvent\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([eventArg, attributesArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Callbacks for custom toolbar item interactions
///
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol CustomToolbarCallbacksProtocol {
  /// Called when a custom toolbar item is tapped
  func onCustomToolbarItemTapped(identifier identifierArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void)
}
class CustomToolbarCallbacks: CustomToolbarCallbacksProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: NutrientApiPigeonCodec {
    return NutrientApiPigeonCodec.shared
  }
  /// Called when a custom toolbar item is tapped
  func onCustomToolbarItemTapped(identifier identifierArg: String, completion: @escaping (Result<Void, NutrientApiError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nutrient_flutter.CustomToolbarCallbacks.onCustomToolbarItemTapped\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([identifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(NutrientApiError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Manages annotations for a PDF document with proper data preservation.
///
/// This API replaces the deprecated annotation methods in PdfDocumentApi
/// and provides a safe way to update annotations without losing attachments
/// or custom data.
///
/// **Channel Management**: Each document instance creates its own AnnotationManager
/// with a unique channel ID prefixed by the document ID (e.g., "doc123_annotation_manager").
/// This allows multiple documents to have independent annotation managers.
///
/// **Key Features**:
/// - Preserves attachments when updating annotation properties
/// - Maintains custom data during updates
/// - Only updates properties that are explicitly set (non-null)
/// - Provides batch update capabilities
/// - Supports search and filtering operations
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol AnnotationManagerApi {
  /// Initialize the annotation manager for a specific document.
  /// This should be called once when creating the manager instance.
  ///
  /// @param documentId The unique identifier of the document
  func initialize(documentId: String) throws
  /// Get the current properties of an annotation.
  /// Returns null if the annotation doesn't exist.
  ///
  /// @param pageIndex Zero-based page index
  /// @param annotationId Unique identifier of the annotation
  /// @return Current annotation properties or null if not found
  func getAnnotationProperties(pageIndex: Int64, annotationId: String, completion: @escaping (Result<AnnotationProperties?, Error>) -> Void)
  /// Save modified annotation properties.
  /// Only non-null properties in modifiedProperties will be updated.
  /// All other properties (including attachments and custom data) are preserved.
  ///
  /// @param modifiedProperties Properties to update (only non-null values are applied)
  /// @return true if successfully saved, false otherwise
  func saveAnnotationProperties(modifiedProperties: AnnotationProperties, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Get all annotations on a specific page.
  ///
  /// @param pageIndex Zero-based page index
  /// @param annotationType Type of annotations to retrieve (e.g., "all", "ink", "note")
  /// @return List of annotations as JSON-compatible maps
  func getAnnotations(pageIndex: Int64, annotationType: String, completion: @escaping (Result<Any, Error>) -> Void)
  /// Add a new annotation to the document.
  ///
  /// @param jsonAnnotation JSON representation of the annotation
  /// @param jsonAttachment Optional JSON representation of attachment (for file/image annotations)
  /// @return Unique identifier of the created annotation
  func addAnnotation(jsonAnnotation: String, jsonAttachment: String?, completion: @escaping (Result<String, Error>) -> Void)
  /// Remove an annotation from the document.
  ///
  /// @param pageIndex Zero-based page index
  /// @param annotationId Unique identifier of the annotation
  /// @return true if successfully removed, false otherwise
  func removeAnnotation(pageIndex: Int64, annotationId: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Search for annotations containing specific text.
  ///
  /// @param query Search term
  /// @param pageIndex Optional page index to limit search scope
  /// @return List of matching annotations
  func searchAnnotations(query: String, pageIndex: Int64?, completion: @escaping (Result<Any, Error>) -> Void)
  /// Export annotations as XFDF format.
  ///
  /// @param pageIndex Optional page index to export specific page annotations
  /// @return XFDF string representation
  func exportXFDF(pageIndex: Int64?, completion: @escaping (Result<String, Error>) -> Void)
  /// Import annotations from XFDF format.
  ///
  /// @param xfdfString XFDF string to import
  /// @return true if successfully imported, false otherwise
  func importXFDF(xfdfString: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Get all annotations that have unsaved changes.
  ///
  /// @return List of annotations with pending changes
  func getUnsavedAnnotations(completion: @escaping (Result<Any, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class AnnotationManagerApiSetup {
  static var codec: FlutterStandardMessageCodec { NutrientApiPigeonCodec.shared }
  /// Sets up an instance of `AnnotationManagerApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: AnnotationManagerApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Initialize the annotation manager for a specific document.
    /// This should be called once when creating the manager instance.
    ///
    /// @param documentId The unique identifier of the document
    let initializeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.initialize\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initializeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let documentIdArg = args[0] as! String
        do {
          try api.initialize(documentId: documentIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      initializeChannel.setMessageHandler(nil)
    }
    /// Get the current properties of an annotation.
    /// Returns null if the annotation doesn't exist.
    ///
    /// @param pageIndex Zero-based page index
    /// @param annotationId Unique identifier of the annotation
    /// @return Current annotation properties or null if not found
    let getAnnotationPropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.getAnnotationProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAnnotationPropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        let annotationIdArg = args[1] as! String
        api.getAnnotationProperties(pageIndex: pageIndexArg, annotationId: annotationIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAnnotationPropertiesChannel.setMessageHandler(nil)
    }
    /// Save modified annotation properties.
    /// Only non-null properties in modifiedProperties will be updated.
    /// All other properties (including attachments and custom data) are preserved.
    ///
    /// @param modifiedProperties Properties to update (only non-null values are applied)
    /// @return true if successfully saved, false otherwise
    let saveAnnotationPropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.saveAnnotationProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      saveAnnotationPropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modifiedPropertiesArg = args[0] as! AnnotationProperties
        api.saveAnnotationProperties(modifiedProperties: modifiedPropertiesArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      saveAnnotationPropertiesChannel.setMessageHandler(nil)
    }
    /// Get all annotations on a specific page.
    ///
    /// @param pageIndex Zero-based page index
    /// @param annotationType Type of annotations to retrieve (e.g., "all", "ink", "note")
    /// @return List of annotations as JSON-compatible maps
    let getAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.getAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAnnotationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        let annotationTypeArg = args[1] as! String
        api.getAnnotations(pageIndex: pageIndexArg, annotationType: annotationTypeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAnnotationsChannel.setMessageHandler(nil)
    }
    /// Add a new annotation to the document.
    ///
    /// @param jsonAnnotation JSON representation of the annotation
    /// @param jsonAttachment Optional JSON representation of attachment (for file/image annotations)
    /// @return Unique identifier of the created annotation
    let addAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.addAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let jsonAnnotationArg = args[0] as! String
        let jsonAttachmentArg: String? = nilOrValue(args[1])
        api.addAnnotation(jsonAnnotation: jsonAnnotationArg, jsonAttachment: jsonAttachmentArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addAnnotationChannel.setMessageHandler(nil)
    }
    /// Remove an annotation from the document.
    ///
    /// @param pageIndex Zero-based page index
    /// @param annotationId Unique identifier of the annotation
    /// @return true if successfully removed, false otherwise
    let removeAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.removeAnnotation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg = args[0] as! Int64
        let annotationIdArg = args[1] as! String
        api.removeAnnotation(pageIndex: pageIndexArg, annotationId: annotationIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeAnnotationChannel.setMessageHandler(nil)
    }
    /// Search for annotations containing specific text.
    ///
    /// @param query Search term
    /// @param pageIndex Optional page index to limit search scope
    /// @return List of matching annotations
    let searchAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.searchAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      searchAnnotationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let queryArg = args[0] as! String
        let pageIndexArg: Int64? = nilOrValue(args[1])
        api.searchAnnotations(query: queryArg, pageIndex: pageIndexArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      searchAnnotationsChannel.setMessageHandler(nil)
    }
    /// Export annotations as XFDF format.
    ///
    /// @param pageIndex Optional page index to export specific page annotations
    /// @return XFDF string representation
    let exportXFDFChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.exportXFDF\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exportXFDFChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageIndexArg: Int64? = nilOrValue(args[0])
        api.exportXFDF(pageIndex: pageIndexArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exportXFDFChannel.setMessageHandler(nil)
    }
    /// Import annotations from XFDF format.
    ///
    /// @param xfdfString XFDF string to import
    /// @return true if successfully imported, false otherwise
    let importXFDFChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.importXFDF\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      importXFDFChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let xfdfStringArg = args[0] as! String
        api.importXFDF(xfdfString: xfdfStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      importXFDFChannel.setMessageHandler(nil)
    }
    /// Get all annotations that have unsaved changes.
    ///
    /// @return List of annotations with pending changes
    let getUnsavedAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nutrient_flutter.AnnotationManagerApi.getUnsavedAnnotations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getUnsavedAnnotationsChannel.setMessageHandler { _, reply in
        api.getUnsavedAnnotations { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getUnsavedAnnotationsChannel.setMessageHandler(nil)
    }
  }
}
